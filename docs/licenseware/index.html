<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>licenseware API documentation</title>
<meta name="description" content="Documentation automatically generated with [`pdoc3`](https://pdoc3.github.io/pdoc/) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>licenseware</code></h1>
</header>
<section id="section-intro">
<p>Documentation automatically generated with <a href="https://pdoc3.github.io/pdoc/"><code>pdoc3</code></a>.</p>
<h1 id="what-is-an-app">What is an <code>App</code>?</h1>
<p>Each Licenseware <code>App</code>/<code>Service</code> is responsible for:</p>
<ul>
<li>processing files submitted by the user;</li>
<li>creating custom reports based on prcessed data from files. </li>
</ul>
<p>Each <strong>APP</strong> has:</p>
<ul>
<li>one or more uploaders</li>
<li>one or more reports </li>
</ul>
<p>Each <strong>UPLOADER</strong> has:</p>
<ul>
<li>one file validator class</li>
<li>one file processing function</li>
</ul>
<p>Each <strong>REPORT</strong> has:</p>
<ul>
<li>one or more report components</li>
<li>report components can be attached either to app builder instance or to report builder instance</li>
</ul>
<h1 id="set-environment-variables">Set environment variables</h1>
<p>Fist make sure you have set the environment variables:</p>
<pre><code class="language-bash">#.env

FLASK_APP=main:app

APP_ID=ifmp
APP_HOST=http://localhost:5000

LWARE_IDENTITY_USER=John
LWARE_IDENTITY_PASSWORD=secret

AUTH_SERVICE_URL=http://localhost:5000/auth
AUTH_SERVICE_USERS_URL_PATH=/users
AUTH_SERVICE_MACHINES_URL_PATH=/machines

REGISTRY_SERVICE_URL=http://localhost:5000/registry-service

FILE_UPLOAD_PATH=/tmp/lware

MONGO_ROOT_USERNAME=John
MONGO_ROOT_PASSWORD=secret
MONGO_HOSTNAME=localhost
MONGO_PORT=27017
MONGO_DATABASE_NAME=db
MONGO_CONNECTION_STRING=mongodb://${MONGO_HOSTNAME}:${MONGO_PORT}/${MONGO_DATABASE_NAME}


REDIS_HOST=redis_db_sdk
REDIS_PORT=6379

</code></pre>
<p>Start <code>redis</code> and <code>mongo</code> databases:</p>
<pre><code class="language-bash">make up
</code></pre>
<h1 id="app-declaration"><code>App</code> declaration</h1>
<p><code>AppBuilder</code> class will be used to define our <code>App</code>.
This class will handle: </p>
<ul>
<li>automatic api generation;</li>
<li>sending to registry service information about <code><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code>, <code><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code>, <code><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code> and others if needed.</li>
</ul>
<pre><code class="language-py">#app_definition.py

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import flags


ifmp_app = AppBuilder(
    name = 'Infrastructure Mapper',
    description = 'Overview of devices and networks',
    flags = [flags.BETA]
)


</code></pre>
<p>The <code>ifmp_app</code> instance is now ready to attach other uploaders, reports, report components (or others) using <em>ifmp_app.register_X</em> methods.</p>
<h1 id="uploader-declaration"><code>Uploader</code> declaration</h1>
<p>The uploader is responsible for:</p>
<ul>
<li>validating files received from user;</li>
<li>calculating quota for user and sending the appropiate response if quota exceded;</li>
<li>uploading files to disk;</li>
<li>triggering <code>worker_function</code> to process the files in the background; </li>
</ul>
<p>Each uploader needs a <code>validator_class</code> and a <code>worker_function</code>.
</p>
<h2 id="creating-the-worker_function">Creating the <code>worker_function</code></h2>
<p>Here is the worker function which will process the files in the background.</p>
<pre><code class="language-py">#worker.py

from licenseware.utils.logger import log

def rv_tools_worker(event_data):
    log.info(&quot;Starting working&quot;)
    # custom logic here
    log.info(&quot;Finished working&quot;)

</code></pre>
<p>The <code>event_data</code> will be a dictionary with the following contents:</p>
<pre><code class="language-js">
{
    'tenant_id': &quot;uuid4 tenant id from flask request.headers&quot;,
    'filepaths': [&quot;absolute/path/to/files/uploaded&quot;],
    'headers':  'flask request.headers',
    'json':  'flask request.json',
}

</code></pre>
<p>Based on given <code>event_data</code> the <code>worker_function</code> will process the files.</p>
<h2 id="creating-the-validator_class">Creating the <code>validator_class</code></h2>
<p>Here we are defining the validation and quota calculation required for each upload.</p>
<p>Create a new class which inherits from <code>UploaderValidator</code> and overwrite <code>calculate_quota</code> function.
Method <code>calculate_quota</code> receives a flask request as a parameter which can be used to extract files and tenant_id needed for quota calculation.</p>
<p>Finally, instantiate the validator class with the required parameters needed for validation.</p>
<pre><code class="language-py">#validator.py

from typing import Tuple
from licenseware.uploader_validator import UploaderValidator


class RVToolsUploaderValidator(UploaderValidator):

    def calculate_quota(self, flask_request) -&gt; Tuple[dict, int]:

        file_objects = flask_request.files.getlist(&quot;files[]&quot;)

        # custom logic for quota calculation

        if quota_ok:
            return {'status': 'success', 'message': 'Quota within limits'}, 200
        else:
            return {'status': 'fail', 'message': 'Quota exceeded'}, 402



rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = ['RV', 'Tools'],
    filename_endswith = ['.xls', '.xlsx'],
    ignore_filenames  = ['skip_this_file.csv'],
    required_input_type = &quot;excel&quot;,
    min_rows_number = 1,
    required_sheets = ['tabvInfo', 'tabvCPU', 'tabvHost', 'tabvCluster'],
    required_columns = [
        'VM', 'Host', 'OS', 'Sockets', 'CPUs', 'Model', 'CPU Model',
        'Cluster', '# CPU', '# Cores', 'ESX Version', 'HT Active',
        'Name', 'NumCpuThreads', 'NumCpuCores'
    ]
)


</code></pre>
<p>If parameters provided for validating filenames and contents are not enough
you can also overwrite <code>get_filenames_response</code> and <code>get_file_objects_response</code> methods.</p>
<ul>
<li><code>get_filenames_response</code> : given a flask request object validates filenames and returns a json response, status code</li>
<li><code>get_file_objects_response</code> : given a flask request object validates filenames and contents and returns a json response, status code</li>
</ul>
<p>Now we have <code>rv_tools_validator</code> as a <code>validator_class</code> and
<code>rv_tools_worker</code> as a <code>worker_function</code>.</p>
<pre><code class="language-py">#uploader.py

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator

from ...worker import rv_tools_worker
from ...validator import rv_tools_validator



rv_tools_uploader = UploaderBuilder(
    name=&quot;RVTools&quot;, 
    uploader_id = 'rv_tools',
    description=&quot;XLSX export from RVTools after scanning your Vmware infrastructure.&quot;, 
    accepted_file_types=['.xls', '.xlsx'],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker
)


</code></pre>
<p>Great! Now we have an uploader defined!</p>
<p>We can later import the uploader in our main file and register it to our defined <code>App</code>.
The registering process will take care of api generation for uploaders.</p>
<pre><code class="language-py">ifmp_app.register_uploader(rv_tools_uploader)
</code></pre>
<p>Of course defining an uploader can be defined in just one file too.</p>
<h1 id="report-declaration"><code>Report</code> declaration</h1>
<p>A <code>Report</code> is composed of one or more <code>report components</code>.
Each report component will inherit from <code>BaseReportComponent</code> class.</p>
<h2 id="creating-the-report-component">Creating the <code>Report component</code></h2>
<p>The following methods will need to be overwrited:</p>
<ul>
<li>
<p><code>get_data</code> : receives a flask request needs to return data for the declared report component;</p>
<ul>
<li>use <code>match_filters = self.get_mongo_match_filters(flask_request)</code> to get default pipeline filters (tenant_id and filters from front-end);</li>
</ul>
</li>
<li>
<p><code>set_attributes</code> : return based on <code>component_type</code> component metadata which is used by front-end to render data received from <code>get_data</code> method;</p>
</li>
<li><code>set_style_attributes</code> : return component style metadata which is used by front-end to apply different css attributes
(width, height, color etc);</li>
</ul>
<p>A <code>NotImplmentedError</code> exception will raise if methods mentioned up are not overwritted.</p>
<pre><code class="language-py">#some_report_component.py

from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import style_attributes as styles
from licenseware.common.constants import icons


class VirtualOverview(BaseReportComponent):

    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type

        super().__init__(**vars(self))


    def get_data(self, flask_request):

        match_filters = self.get_mongo_match_filters(flask_request)

        log.info(match_filters)

        return ['mongo pipeline result']


    def set_attributes(self):

        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&quot;number_of_devices&quot;, icons.SERVERS), 
            (&quot;number_of_databases&quot;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)


        # Or raw dict (same results are achived using the method up)

        attributes = {'series': [
            {
                'value_description': 'Number of devices',
                'value_key': 'number_of_devices',
                'icon': 'ServersIcon'
            },
            {
                'value_description': 'Number of databases',
                'value_key': 'number_of_databases',
                'icon': 'DatabaseIconRounded'
            }
        ]}

        # You can also return attributes
        return attributes


    def set_style_attributes(self):

        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            'width': '1/3'
        }

        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])

        return style_attributes


virtual_overview = VirtualOverview(
    title=&quot;Overview&quot;,
    component_id=&quot;virtual_overview&quot;,
    component_type='summary'
)


</code></pre>
<p>Now <code>virtual_overview</code> is our <code>report_component</code>.</p>
<p>We can later register the component straight to the <code>App</code> or <code>Report</code></p>
<pre><code class="language-py">ifmp_app.register_report_component(virtual_overview)
</code></pre>
<h2 id="creating-the-report">Creating the <code>Report</code></h2>
<p>The report can hold one or more report components. </p>
<pre><code class="language-py">#report.py

from licenseware.report_builder import ReportBuilder
from ...some_report_component import virtual_overview


virtualization_details_report = ReportBuilder(
    name=&quot;Virtualization Details&quot;,
    report_id=&quot;virtualization_details&quot;,
    description=&quot;This report gives you a detailed view of your virtual infrastructure.&quot;,
    connected_apps=['ifmp-service'],
    report_components=[
        virtual_overview        
    ]
)

</code></pre>
<p>We can later add the report to our main <code>App</code></p>
<pre><code class="language-py">ifmp_app.register_report(virtualization_details_report)
</code></pre>
<p>Reports api will be handled by the <code>ifmp_app</code> instance.</p>
<h1 id="custom-namespaces">Custom namespaces</h1>
<p>We are not restricted using just the apis generated from <code>AppBuilder</code> we can add new custom ones to <code>App</code>/<code>ifmp_app</code>.</p>
<pre><code class="language-py">#some_namespace.py

from flask_restx import Namespace, Resource


ns = Namespace(
    name=&quot;Custom&quot;, 
    description=&quot;This is a custom namespace with the app prefix&quot;
)

@ns.route(&quot;/custom-api-route&quot;)
class CustomApiRoute(Resource):    
    @ns.doc(id=&quot;custom&quot;)
    def get(self):
        return &quot;custom-api-route&quot;

</code></pre>
<p>We can later import the namespace created to our <code>main</code> file</p>
<pre><code class="language-py">ifmp_app.add_namespace(custom_ns, path='/ns-prefix')
</code></pre>
<p><code>ifmp_app</code> will make sure it will have the app prefix.</p>
<p>If the custom namespace created is repetead for all apps consider adding it to <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> package.</p>
<h1 id="apis-from-simple-functions">Apis from simple functions</h1>
<p>Class <code>EndpointBuilder</code> can be used to generate endpoints from simple functions.
The function name will be used to extract the http method and the route path (<code>get_custom_data_from_mongo</code> &ndash;&gt;
<code>GET</code> http-method, <code>/get_custom_data_from_mongo</code> path-route)</p>
<pre><code class="language-py">#func.py

from licenseware.endpoint_builder import EndpointBuilder

def get_custom_data_from_mongo(flask_request):
    &quot;&quot;&quot; Custom documentation &quot;&quot;&quot;

    # Some logic here

    return &quot;Some data&quot;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)
</code></pre>
<p>The function will receive a flask request as a parameter and will be added to <code>/custom_endpoint/get_custom_data_from_mongo</code></p>
<p>Later in our <code>main</code> file: </p>
<pre><code class="language-py">ifmp_app.register_endpoint(custom_func_endpoint)
</code></pre>
<h1 id="the-main-file">The <code>main</code> file</h1>
<pre><code class="language-py">
from flask import Flask
from ...app_definition import ifmp_app
from ...uploader import rv_tools_uploader
from ...some_report_component import virtual_overview
from ...report import virtualization_details_report
from ...some_namespace import ns as custom_ns
from ...func import custom_func_endpoint


app = Flask(__name__)


# These can be placed in `app_definition`  

ifmp_app.register_uploader(rv_tools_uploader)
ifmp_app.register_report_component(virtual_overview)
ifmp_app.register_report(virtualization_details_report)
ifmp_app.add_namespace(custom_ns, path='/ns-prefix')
ifmp_app.register_endpoint(custom_func_endpoint)


# Just like any other flask extension
ifmp_app.init_app(app, register=True)    

# register=True - if True will send registration information to registry-service 


if __name__ == &quot;__main__&quot;:    
    app.run(port=4000, debug=True)


</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;

Documentation automatically generated with [`pdoc3`](https://pdoc3.github.io/pdoc/).

# What is an `App`?

Each Licenseware `App`/`Service` is responsible for:

- processing files submitted by the user;
- creating custom reports based on prcessed data from files. 


Each **APP** has:

- one or more uploaders
- one or more reports 

Each **UPLOADER** has:

- one file validator class
- one file processing function


Each **REPORT** has:

- one or more report components
- report components can be attached either to app builder instance or to report builder instance


# Set environment variables

Fist make sure you have set the environment variables:

```bash
#.env

FLASK_APP=main:app

APP_ID=ifmp
APP_HOST=http://localhost:5000

LWARE_IDENTITY_USER=John
LWARE_IDENTITY_PASSWORD=secret

AUTH_SERVICE_URL=http://localhost:5000/auth
AUTH_SERVICE_USERS_URL_PATH=/users
AUTH_SERVICE_MACHINES_URL_PATH=/machines

REGISTRY_SERVICE_URL=http://localhost:5000/registry-service

FILE_UPLOAD_PATH=/tmp/lware

MONGO_ROOT_USERNAME=John
MONGO_ROOT_PASSWORD=secret
MONGO_HOSTNAME=localhost
MONGO_PORT=27017
MONGO_DATABASE_NAME=db
MONGO_CONNECTION_STRING=mongodb://${MONGO_HOSTNAME}:${MONGO_PORT}/${MONGO_DATABASE_NAME}


REDIS_HOST=redis_db_sdk
REDIS_PORT=6379

```

Start `redis` and `mongo` databases:

```bash
make up
```


# `App` declaration

`AppBuilder` class will be used to define our `App`. 
This class will handle: 

- automatic api generation;
- sending to registry service information about `uploader_builder`, `report_builder`, `report_components` and others if needed.


```py
#app_definition.py

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import flags


ifmp_app = AppBuilder(
    name = &#39;Infrastructure Mapper&#39;,
    description = &#39;Overview of devices and networks&#39;,
    flags = [flags.BETA]
)


```

The `ifmp_app` instance is now ready to attach other uploaders, reports, report components (or others) using *ifmp_app.register_X* methods.


# `Uploader` declaration

The uploader is responsible for:

- validating files received from user;
- calculating quota for user and sending the appropiate response if quota exceded;
- uploading files to disk;
- triggering `worker_function` to process the files in the background; 

Each uploader needs a `validator_class` and a `worker_function`.  


## Creating the `worker_function`

Here is the worker function which will process the files in the background.

```py
#worker.py

from licenseware.utils.logger import log

def rv_tools_worker(event_data):
    log.info(&#34;Starting working&#34;)
    # custom logic here
    log.info(&#34;Finished working&#34;)
    
```

The `event_data` will be a dictionary with the following contents:

```js

{
    &#39;tenant_id&#39;: &#34;uuid4 tenant id from flask request.headers&#34;,
    &#39;filepaths&#39;: [&#34;absolute/path/to/files/uploaded&#34;],
    &#39;headers&#39;:  &#39;flask request.headers&#39;,
    &#39;json&#39;:  &#39;flask request.json&#39;,
}

```

Based on given `event_data` the `worker_function` will process the files.


## Creating the `validator_class`

Here we are defining the validation and quota calculation required for each upload.

Create a new class which inherits from `UploaderValidator` and overwrite `calculate_quota` function.
Method `calculate_quota` receives a flask request as a parameter which can be used to extract files and tenant_id needed for quota calculation.

Finally, instantiate the validator class with the required parameters needed for validation.

```py
#validator.py

from typing import Tuple
from licenseware.uploader_validator import UploaderValidator


class RVToolsUploaderValidator(UploaderValidator):
    
    def calculate_quota(self, flask_request) -&gt; Tuple[dict, int]:
    
        file_objects = flask_request.files.getlist(&#34;files[]&#34;)
        
        # custom logic for quota calculation
        
        if quota_ok:
            return {&#39;status&#39;: &#39;success&#39;, &#39;message&#39;: &#39;Quota within limits&#39;}, 200
        else:
            return {&#39;status&#39;: &#39;fail&#39;, &#39;message&#39;: &#39;Quota exceeded&#39;}, 402



rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = [&#39;RV&#39;, &#39;Tools&#39;],
    filename_endswith = [&#39;.xls&#39;, &#39;.xlsx&#39;],
    ignore_filenames  = [&#39;skip_this_file.csv&#39;],
    required_input_type = &#34;excel&#34;,
    min_rows_number = 1,
    required_sheets = [&#39;tabvInfo&#39;, &#39;tabvCPU&#39;, &#39;tabvHost&#39;, &#39;tabvCluster&#39;],
    required_columns = [
        &#39;VM&#39;, &#39;Host&#39;, &#39;OS&#39;, &#39;Sockets&#39;, &#39;CPUs&#39;, &#39;Model&#39;, &#39;CPU Model&#39;,
        &#39;Cluster&#39;, &#39;# CPU&#39;, &#39;# Cores&#39;, &#39;ESX Version&#39;, &#39;HT Active&#39;,
        &#39;Name&#39;, &#39;NumCpuThreads&#39;, &#39;NumCpuCores&#39;
    ]
)


```

If parameters provided for validating filenames and contents are not enough 
you can also overwrite `get_filenames_response` and `get_file_objects_response` methods.

- `get_filenames_response` : given a flask request object validates filenames and returns a json response, status code
- `get_file_objects_response` : given a flask request object validates filenames and contents and returns a json response, status code


Now we have `rv_tools_validator` as a `validator_class` and  `rv_tools_worker` as a `worker_function`.


```py
#uploader.py

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator

from ...worker import rv_tools_worker
from ...validator import rv_tools_validator



rv_tools_uploader = UploaderBuilder(
    name=&#34;RVTools&#34;, 
    uploader_id = &#39;rv_tools&#39;,
    description=&#34;XLSX export from RVTools after scanning your Vmware infrastructure.&#34;, 
    accepted_file_types=[&#39;.xls&#39;, &#39;.xlsx&#39;],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker
)


```

Great! Now we have an uploader defined!

We can later import the uploader in our main file and register it to our defined `App`.
The registering process will take care of api generation for uploaders.

```py
ifmp_app.register_uploader(rv_tools_uploader)
```

Of course defining an uploader can be defined in just one file too.



# `Report` declaration

A `Report` is composed of one or more `report components`. 
Each report component will inherit from `BaseReportComponent` class.


## Creating the `Report component`

The following methods will need to be overwrited:

- `get_data` : receives a flask request needs to return data for the declared report component;
    - use `match_filters = self.get_mongo_match_filters(flask_request)` to get default pipeline filters (tenant_id and filters from front-end);

- `set_attributes` : return based on `component_type` component metadata which is used by front-end to render data received from `get_data` method;
- `set_style_attributes` : return component style metadata which is used by front-end to apply different css attributes  (width, height, color etc);

A `NotImplmentedError` exception will raise if methods mentioned up are not overwritted.


```py
#some_report_component.py

from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import style_attributes as styles
from licenseware.common.constants import icons


class VirtualOverview(BaseReportComponent):
            
    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type
        
        super().__init__(**vars(self))
        
        
    def get_data(self, flask_request):
        
        match_filters = self.get_mongo_match_filters(flask_request)
        
        log.info(match_filters)

        return [&#39;mongo pipeline result&#39;]
    
    
    def set_attributes(self):
        
        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&#34;number_of_devices&#34;, icons.SERVERS), 
            (&#34;number_of_databases&#34;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)
        
        
        # Or raw dict (same results are achived using the method up)
        
        attributes = {&#39;series&#39;: [
            {
                &#39;value_description&#39;: &#39;Number of devices&#39;,
                &#39;value_key&#39;: &#39;number_of_devices&#39;,
                &#39;icon&#39;: &#39;ServersIcon&#39;
            },
            {
                &#39;value_description&#39;: &#39;Number of databases&#39;,
                &#39;value_key&#39;: &#39;number_of_databases&#39;,
                &#39;icon&#39;: &#39;DatabaseIconRounded&#39;
            }
        ]}
        
        # You can also return attributes
        return attributes
        
        
    def set_style_attributes(self):
        
        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            &#39;width&#39;: &#39;1/3&#39;
        }
        
        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])
        
        return style_attributes
        

virtual_overview = VirtualOverview(
    title=&#34;Overview&#34;,
    component_id=&#34;virtual_overview&#34;,
    component_type=&#39;summary&#39;
)


```

Now `virtual_overview` is our `report_component`.

We can later register the component straight to the `App` or `Report`
```py
ifmp_app.register_report_component(virtual_overview)
```

## Creating the `Report`

The report can hold one or more report components. 


```py
#report.py

from licenseware.report_builder import ReportBuilder
from ...some_report_component import virtual_overview


virtualization_details_report = ReportBuilder(
    name=&#34;Virtualization Details&#34;,
    report_id=&#34;virtualization_details&#34;,
    description=&#34;This report gives you a detailed view of your virtual infrastructure.&#34;,
    connected_apps=[&#39;ifmp-service&#39;],
    report_components=[
        virtual_overview        
    ]
)

```

We can later add the report to our main `App`

```py
ifmp_app.register_report(virtualization_details_report)
```

Reports api will be handled by the `ifmp_app` instance.


# Custom namespaces

We are not restricted using just the apis generated from `AppBuilder` we can add new custom ones to `App`/`ifmp_app`.



```py
#some_namespace.py

from flask_restx import Namespace, Resource


ns = Namespace(
    name=&#34;Custom&#34;, 
    description=&#34;This is a custom namespace with the app prefix&#34;
)

@ns.route(&#34;/custom-api-route&#34;)
class CustomApiRoute(Resource):    
    @ns.doc(id=&#34;custom&#34;)
    def get(self):
        return &#34;custom-api-route&#34;

```

We can later import the namespace created to our `main` file

```py
ifmp_app.add_namespace(custom_ns, path=&#39;/ns-prefix&#39;)
```

`ifmp_app` will make sure it will have the app prefix.

If the custom namespace created is repetead for all apps consider adding it to `app_builder` package.




# Apis from simple functions

Class `EndpointBuilder` can be used to generate endpoints from simple functions.
The function name will be used to extract the http method and the route path (`get_custom_data_from_mongo` --&gt;
`GET` http-method, `/get_custom_data_from_mongo` path-route)

```py
#func.py

from licenseware.endpoint_builder import EndpointBuilder

def get_custom_data_from_mongo(flask_request):
    &#34;&#34;&#34; Custom documentation &#34;&#34;&#34;
    
    # Some logic here

    return &#34;Some data&#34;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)
```

The function will receive a flask request as a parameter and will be added to `/custom_endpoint/get_custom_data_from_mongo`

Later in our `main` file: 
```py
ifmp_app.register_endpoint(custom_func_endpoint)
```


# The `main` file

```py

from flask import Flask
from ...app_definition import ifmp_app
from ...uploader import rv_tools_uploader
from ...some_report_component import virtual_overview
from ...report import virtualization_details_report
from ...some_namespace import ns as custom_ns
from ...func import custom_func_endpoint


app = Flask(__name__)


# These can be placed in `app_definition`  

ifmp_app.register_uploader(rv_tools_uploader)
ifmp_app.register_report_component(virtual_overview)
ifmp_app.register_report(virtualization_details_report)
ifmp_app.add_namespace(custom_ns, path=&#39;/ns-prefix&#39;)
ifmp_app.register_endpoint(custom_func_endpoint)


# Just like any other flask extension
ifmp_app.init_app(app, register=True)    
    
# register=True - if True will send registration information to registry-service 


if __name__ == &#34;__main__&#34;:    
    app.run(port=4000, debug=True)


```






&#39;&#39;&#39;


from dotenv import load_dotenv

load_dotenv()  </code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code></dt>
<dd>
<div class="desc"><p>In the <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> package we define the <code>app</code> and build routes â€¦</p></div>
</dd>
<dt><code class="name"><a title="licenseware.auth" href="auth/index.html">licenseware.auth</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.cli" href="cli/index.html">licenseware.cli</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.common" href="common/index.html">licenseware.common</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.decorators" href="decorators/index.html">licenseware.decorators</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.editable_tables" href="editable_tables/index.html">licenseware.editable_tables</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.endpoint_builder" href="endpoint_builder/index.html">licenseware.endpoint_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.mongodata" href="mongodata/index.html">licenseware.mongodata</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.namespace_generator" href="namespace_generator/index.html">licenseware.namespace_generator</a></code></dt>
<dd>
<div class="desc"><p>This module makes available the <code>namespace</code> decorator
which can be used to generate flask_restx namespace from marshmallow schema â€¦</p></div>
</dd>
<dt><code class="name"><a title="licenseware.quota" href="quota/index.html">licenseware.quota</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.registry_service" href="registry_service/index.html">licenseware.registry_service</a></code></dt>
<dd>
<div class="desc"><p>All calls to registry service should be added in this package</p></div>
</dd>
<dt><code class="name"><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.tenants" href="tenants/index.html">licenseware.tenants</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.uploader_validator" href="uploader_validator/index.html">licenseware.uploader_validator</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.utils" href="utils/index.html">licenseware.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#what-is-an-app">What is an App?</a></li>
<li><a href="#set-environment-variables">Set environment variables</a></li>
<li><a href="#app-declaration">App declaration</a></li>
<li><a href="#uploader-declaration">Uploader declaration</a><ul>
<li><a href="#creating-the-worker_function">Creating the worker_function</a></li>
<li><a href="#creating-the-validator_class">Creating the validator_class</a></li>
</ul>
</li>
<li><a href="#report-declaration">Report declaration</a><ul>
<li><a href="#creating-the-report-component">Creating the Report component</a></li>
<li><a href="#creating-the-report">Creating the Report</a></li>
</ul>
</li>
<li><a href="#custom-namespaces">Custom namespaces</a></li>
<li><a href="#apis-from-simple-functions">Apis from simple functions</a></li>
<li><a href="#the-main-file">The main file</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code></li>
<li><code><a title="licenseware.auth" href="auth/index.html">licenseware.auth</a></code></li>
<li><code><a title="licenseware.cli" href="cli/index.html">licenseware.cli</a></code></li>
<li><code><a title="licenseware.common" href="common/index.html">licenseware.common</a></code></li>
<li><code><a title="licenseware.decorators" href="decorators/index.html">licenseware.decorators</a></code></li>
<li><code><a title="licenseware.editable_tables" href="editable_tables/index.html">licenseware.editable_tables</a></code></li>
<li><code><a title="licenseware.endpoint_builder" href="endpoint_builder/index.html">licenseware.endpoint_builder</a></code></li>
<li><code><a title="licenseware.mongodata" href="mongodata/index.html">licenseware.mongodata</a></code></li>
<li><code><a title="licenseware.namespace_generator" href="namespace_generator/index.html">licenseware.namespace_generator</a></code></li>
<li><code><a title="licenseware.quota" href="quota/index.html">licenseware.quota</a></code></li>
<li><code><a title="licenseware.registry_service" href="registry_service/index.html">licenseware.registry_service</a></code></li>
<li><code><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code></li>
<li><code><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code></li>
<li><code><a title="licenseware.tenants" href="tenants/index.html">licenseware.tenants</a></code></li>
<li><code><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code></li>
<li><code><a title="licenseware.uploader_validator" href="uploader_validator/index.html">licenseware.uploader_validator</a></code></li>
<li><code><a title="licenseware.utils" href="utils/index.html">licenseware.utils</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>