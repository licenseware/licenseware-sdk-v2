<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>licenseware API documentation</title>
<meta name="description" content="Licenseware SDK …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>licenseware</code></h1>
</header>
<section id="section-intro">
<h1 id="licenseware-sdk">Licenseware SDK</h1>
<p>This is the licenseware <strong>Python3</strong> sdk useful for creating apps quickly. The SDK handles the repetetive actions needed for creating an app (file uploads/validation, background events, api routes and more). It helps you focus on processsing the files provided and creating the reports based on processed data.
</p>
<h1 id="contents">Contents</h1>
<ol>
<li><a href="#quickstart">Quickstart</a></li>
<li><a href="#what-is-an-app">What is an <code>App</code>?</a></li>
<li><a href="#set-environment-variables">Set environment variables</a></li>
<li><a href="#app-declaration"><code>App</code> declaration</a></li>
<li><a href="#uploader-declaration"><code>Uploader</code> declaration</a></li>
<li><a href="#report-declaration"><code>Report</code> declaration</a></li>
<li><a href="#custom-namespaces">Custom namespaces</a></li>
<li><a href="#endpoints-from-simple-functions">Endpoints from simple functions</a></li>
<li><a href="#the-main-file">The <code>main</code> file</a></li>
<li><a href="#licenseware-cli">Licenseware CLI</a> </li>
</ol>
<p><a name="quickstart"></a></p>
<h1 id="quickstart">QUICKSTART</h1>
<h2 id="install-licenseware-sdk">Install Licenseware SDK</h2>
<p>Install latest update for this package using the following pip command:</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git

</code></pre>
<p>Install from a specific branch</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git@branch_name

</code></pre>
<p>Install from a specific tag</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git@tag_name

</code></pre>
<p>You can use <code>git+ssh</code> if you have ssh keys configured.
Uninstall with <code>pip3 uninstall <a title="licenseware" href="#licenseware">licenseware</a></code>.</p>
<h2 id="how-to-create-a-release">How to create a release</h2>
<ul>
<li>In <code>setup.py</code> update the package version; </li>
<li>Create a tag with that version ex: <code>git tag -a v0.0.11</code>;</li>
<li>You can list available tags with <code>git tag -n</code>;</li>
<li>Push created tag with <code>git push --tags</code></li>
</ul>
<p>Now you use pip to install it from that specific tag:</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git@v0.0.11

</code></pre>
<p>If you want to add more details regarding this package release you can <code>Create a new release</code></p>
<ul>
<li>Click the link <code>Releases</code>;</li>
<li>Click <code>Draft a new release</code>;</li>
<li>Click <code>Tags</code>;</li>
<li>Select latest tag version name;</li>
<li>Add title and description for the release;</li>
</ul>
<p><img alt="" src="pics/release.gif"></p>
<p>Optionally you can create a wheel for this package:</p>
<pre><code class="language-bash">
python3 setup.py bdist_wheel sdist

</code></pre>
<p>And add it to binaries on the release.</p>
<p>Bellow is a full working example of almost all features the sdk provides.</p>
<p>Start the services in the following order:</p>
<ol>
<li><code>make up</code> - mongo and redis;</li>
<li><code>make mock</code> - mock dependency server for our app;</li>
<li><code>make dev</code> - start the app server (<code>make prod</code> to start it with uwsgi);</li>
<li><code>make worker</code> - start the background worker.</li>
</ol>
<pre><code class="language-py">from dotenv import load_dotenv

load_dotenv()  

from flask import Flask
from flask_restx import Namespace, Resource
from marshmallow import Schema, fields

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import (envs, filters, flags, icons,
                                              states)
from licenseware.endpoint_builder import EndpointBuilder
from licenseware.notifications import notify_upload_status
from licenseware.report_builder import ReportBuilder
from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import styles

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator
from licenseware.utils.logger import log



app = Flask(__name__)


# APP

ifmp_app = AppBuilder(
    name = 'Infrastructure Mapper',
    description = 'Overview of devices and networks',
    flags = [flags.BETA]
)


# UPLOADERS



# Here is the worker function 
# which will process the files in the background
def rv_tools_worker(event_data):

    # Event data will contain the following information
    # event_data = {
    #     'tenant_id': 'the tenant_id from request',
    #     'filepaths': 'absolute file paths to the files uploaded',
    #     'uploader_id': 'the uploader id in our case rv_tools'
    #     'headers':  'flask request headers',
    #     'json':  'flask request json data',
    # }

    log.info(&quot;Starting working&quot;)
    notify_upload_status(event_data, status=states.RUNNING)
    log.debug(event_data) # here add the processing file logic
    notify_upload_status(event_data, status=states.IDLE)
    log.info(&quot;Finished working&quot;)




# Here we are defining the validation required for each upload
# If overwriting bellow mentioned methods is not necessary you can use `UploaderValidator` directly 

class RVToolsUploaderValidator(UploaderValidator): 
    # If necessary you can overwrite bellow mentioned methods
    ...

    # def calculate_quota(self, flask_request) -&gt; Tuple[dict, int]:
    # responsible for calculating quota based on tenant_id and returning a json response, status code 
    # ...

    # def get_filenames_response(self, flask_request): 
    # responsible for validating filenames and returning a json response, status code
    # ...

    # def get_file_objects_response(self, flask_request): 
    #   responsible for validating filenames, their contents and returning a json response, status code
    # ...



rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = ['RV', 'Tools'],
    filename_endswith = ['.xls', '.xlsx'],
    ignore_filenames  = ['skip_this_file.csv'],
    required_input_type = &quot;excel&quot;,
    min_rows_number = 1,
    required_sheets = ['tabvInfo', 'tabvCPU', 'tabvHost', 'tabvCluster'],
    required_columns = [
        'VM', 'Host', 'OS', 'Sockets', 'CPUs', 'Model', 'CPU Model',
        'Cluster', '# CPU', '# Cores', 'ESX Version', 'HT Active',
        'Name', 'NumCpuThreads', 'NumCpuCores'
    ]
)

# Here we are creating the uploader 
# Notice we are providing the the validator created up to `validator_class` parameter
# `worker_function` will be called when `uploader_id` is triggered
# The `uploader_id` event is triggered when files are uploaded to `/uploads/uploader_id/files` route

rv_tools_uploader = UploaderBuilder(
    name=&quot;RVTools&quot;, 
    uploader_id = 'rv_tools',
    description=&quot;XLSX export from RVTools after scanning your Vmware infrastructure.&quot;, 
    accepted_file_types=['.xls', '.xlsx'],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker,
    quota_units = 1
)

# Here we are:
# - adding the uploader to the main app (uploaders list)
# - sending uploader information to registry-service
ifmp_app.register_uploader(rv_tools_uploader)




# REPORTS


class VirtualOverview(BaseReportComponent):

    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type

        super().__init__(**vars(self))


    def get_data(self, flask_request):

        match_filters = self.get_mongo_match_filters(flask_request)

        log.info(match_filters)

        return ['mongo pipeline result']


    def set_attributes(self):

        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&quot;number_of_devices&quot;, icons.SERVERS), 
            (&quot;number_of_databases&quot;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)


        # Or raw dict (same results are achived using the method up)

        attributes = {'series': [
            {
                'value_description': 'Number of devices',
                'value_key': 'number_of_devices',
                'icon': 'ServersIcon'
            },
            {
                'value_description': 'Number of databases',
                'value_key': 'number_of_databases',
                'icon': 'DatabaseIconRounded'
            }
        ]}

        # You can also return attributes
        return attributes


    def set_style_attributes(self):

        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            'width': '1/3'
        }

        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])

        return style_attributes


    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&quot;device_name&quot;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&quot;Device Name&quot;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &quot;column&quot;: &quot;database_name&quot;,
                &quot;allowed_filters&quot;: [
                    &quot;equals&quot;, &quot;contains&quot;, &quot;in_list&quot;
                ],
                &quot;visible_name&quot;: &quot;Database Name&quot;
            }

        ]



virtual_overview = VirtualOverview(
    title=&quot;Overview&quot;,
    component_id=&quot;virtual_overview&quot;,
    component_type='summary'
)

# TODO raise component_id conflict
# Register component to registry-service (to act as a first class citizen)
ifmp_app.register_report_component(virtual_overview)



# Component order is determined by it's position in the list
report_components=[
    virtual_overview       
]


# Define a report wich holds one or more report components
virtualization_details_report = ReportBuilder(
    name=&quot;Virtualization Details&quot;,
    report_id=&quot;virtualization_details&quot;,
    description=&quot;This report gives you a detailed view of your virtual infrastructure. Deep dive into the infrastructure topology, identify devices with missing host details and capping rules for licensing.&quot;,
    connected_apps=['ifmp-service'],
    report_components=report_components
)


ifmp_app.register_report(virtualization_details_report)






# CUSTOM RESTX NAMESPACES
# We can add also custom namespaces to main IFMP Api

custom_ns = Namespace(
    name=&quot;Custom&quot;, 
    description=&quot;This is a custom namespace with the app prefix&quot;
)

@custom_ns.route(&quot;/custom-api-route&quot;)
class CustomApiRoute(Resource):    
    @custom_ns.doc(&quot;custom&quot;)
    def get(self):
        return &quot;custom-api-route&quot;

# Add it to main app 
# it will have the same namespace prefix /ifmp/v1/ + ns-prefix/custom-api-route
ifmp_app.add_namespace(custom_ns, path='/ns-prefix')

# If the namespace defined up it's used on all apps 
# add it to licenseware sdk in app_builder default routes



# EndpointBuilder

# Endpoints can be generated from functions or marshmellow schemas
# add http method as a prefix to schema or function handler (get_some_data, PostDeviceDataSchema etc)

# Here we are using a function to create an endpoint like /custom_endpoint/custom_data_from_mongo

def get_custom_data_from_mongo(flask_request):
    &quot;&quot;&quot; Custom documentation &quot;&quot;&quot;

    # Some logic here

    return &quot;Some data&quot;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)

ifmp_app.register_endpoint(custom_func_endpoint)

# Here we are using a schema to generate an endpoint

class GetDeviceData(Schema):

    class Meta:
        collection_name = envs.MONGO_COLLECTION_DATA_NAME

    tenant_id = fields.Str(required=False)
    updated_at = fields.Str(required=False)
    name = fields.Str(required=True)
    occupation = fields.Str(required=False)


custom_schema_endpoint = EndpointBuilder(GetDeviceData)


ifmp_app.register_endpoint(custom_schema_endpoint)


# Call init_app in the flask function factory 
ifmp_app.init_app(app)


if __name__ == &quot;__main__&quot;:   

    # Register app to registry-service
    ifmp_app.register_app()

    app.run(port=4000, debug=True)


</code></pre>
<p>Make commands:</p>
<ul>
<li><code>make up</code> and
<code>make down</code> - start and stop mongo and redis databases;</li>
<li><code>make mock</code> - start mock server which app will use for authentication, registry-service or other external services dependencies;</li>
<li><code>make dev</code> - start application with hot reload;</li>
<li><code>make worker</code> - start dramatiq worker;</li>
<li><code>make test</code> - run all unit tests.</li>
<li><code>make dev-docs</code> - this command will start a pdoc3 http server use for viewing and updating documentation for the app created;</li>
<li><code>make docs</code> - this command will generate html docs based on docstrings provided in the app;</li>
<li><code>make dev-sdk-docs</code> - this command will start a pdoc3 http server use for viewing and updating licenseware sdk documentation for the app created;</li>
<li><code>make sdk-docs</code> - this command will generate html docs based on docstrings provided in the app;</li>
</ul>
<p>Documentation generated can be added later to github pages.</p>
<p>See more about documentation creation here <a href="https://pdoc3.github.io/pdoc/"><code>pdoc3</code></a>.</p>
<p><a name="what-is-an-app"></a></p>
<h1 id="what-is-an-app">What is an <code>App</code>?</h1>
<p>Each Licenseware <code>App</code>/<code>Service</code> is responsible for:</p>
<ul>
<li>processing files submitted by the user;</li>
<li>creating custom reports based on processed data from files. </li>
</ul>
<p>Each <strong>APP</strong> has:</p>
<ul>
<li>one or more uploaders</li>
<li>one or more reports </li>
<li>one or more report components</li>
</ul>
<p>Each <strong>UPLOADER</strong> has:</p>
<ul>
<li>one file validator class</li>
<li>one file processing/worker function</li>
</ul>
<p>Each <strong>REPORT</strong> has:</p>
<ul>
<li>one or more report components</li>
<li>report components can be attached either to app builder instance or to report builder instance</li>
</ul>
<p>Each <strong>REPORT COMPONENT</strong> has:</p>
<ul>
<li>one get_data method;</li>
<li>one url where data can be accessed;</li>
</ul>
<p><a name="set-environment-variables"></a></p>
<h1 id="set-environment-variables">Set environment variables</h1>
<p>Fist make sure you have set the environment variables:</p>
<pre><code class="language-bash">#.env
DEBUG=true
ENVIRONMENT=local
PERSONAL_SUFFIX=_alin


FLASK_APP=main:app

APP_ID=ifmp
APP_HOST=http://localhost:5000

LWARE_IDENTITY_USER=John
LWARE_IDENTITY_PASSWORD=secret

AUTH_SERVICE_URL=http://localhost:5000/auth
AUTH_SERVICE_USERS_URL_PATH=/users
AUTH_SERVICE_MACHINES_URL_PATH=/machines

REGISTRY_SERVICE_URL=http://localhost:5000/registry-service

FILE_UPLOAD_PATH=/tmp/lware

MONGO_ROOT_USERNAME=Alin
MONGO_ROOT_PASSWORD=secret
MONGO_HOSTNAME=localhost
MONGO_PORT=27017
MONGO_DATABASE_NAME=db
MONGO_CONNECTION_STRING=mongodb://${MONGO_HOSTNAME}:${MONGO_PORT}/${MONGO_DATABASE_NAME}


REDIS_HOST=redis_db_sdk
REDIS_PORT=6379

</code></pre>
<p>Start <code>redis</code> and <code>mongo</code> databases:</p>
<pre><code class="language-bash">make up
</code></pre>
<p><a name="app-declaration"></a></p>
<h1 id="app-declaration"><code>App</code> declaration</h1>
<p><code>AppBuilder</code> class will be used to define our <code>App</code>.
This class will handle: </p>
<ul>
<li>automatic api generation;</li>
<li>sending to registry service information about <code><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code>, <code><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code>, <code><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code> and others if needed.</li>
</ul>
<pre><code class="language-py">#app_definition.py

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import flags


ifmp_app = AppBuilder(
    name = 'Infrastructure Mapper',
    description = 'Overview of devices and networks',
    flags = [flags.BETA]
)


</code></pre>
<p>The <code>ifmp_app</code> instance is now ready to attach other uploaders, reports, report components (or others) using <em>ifmp_app.register_X</em> methods.</p>
<p><a name="uploader-declaration"></a></p>
<h1 id="uploader-declaration"><code>Uploader</code> declaration</h1>
<p>The uploader is responsible for:</p>
<ul>
<li>validating files received from user;</li>
<li>calculating quota for user and sending the appropiate response if quota exceded;</li>
<li>uploading files to disk;</li>
<li>triggering <code>worker_function</code> to process the files in the background; </li>
</ul>
<p>Each uploader needs a <code>validator_class</code> and a <code>worker_function</code>.
</p>
<h2 id="creating-the-worker_function">Creating the <code>worker_function</code></h2>
<p>Here is the worker function which will process the files in the background.</p>
<pre><code class="language-py">#worker.py

from licenseware.notification import notify_upload_status
from licenseware.utils.logger import log

def rv_tools_worker(event_data):
    log.info(&quot;Starting working&quot;)
    notify_upload_status(event_data, status=states.RUNNING)
    log.debug(event_data) # here add the processing file logic
    notify_upload_status(event_data, status=states.IDLE)
    log.info(&quot;Finished working&quot;)

</code></pre>
<p>The <code>event_data</code> will be a dictionary with the following contents:</p>
<pre><code class="language-js">
{
    'tenant_id': &quot;uuid4 tenant id from flask request.headers&quot;,
    'filepaths': [&quot;absolute/path/to/files/uploaded&quot;],
    'uploader_id': 'the uploader id in our case rv_tools'
    'headers':  'flask request.headers',
    'json':  'flask request.json',
}

</code></pre>
<p>Based on given <code>event_data</code> the <code>worker_function</code> will process the files.</p>
<h2 id="creating-the-validator_class">Creating the <code>validator_class</code></h2>
<p>Here we are defining the validation and quota calculation required for each upload.</p>
<p>Create a new class which inherits from <code>UploaderValidator</code> and overwrite <code>calculate_quota</code> function.
Method <code>calculate_quota</code> receives a flask request as a parameter which can be used to extract files and tenant_id needed for quota calculation.</p>
<p>Finally, instantiate the validator class with the required parameters needed for validation.</p>
<pre><code class="language-py">#validator.py

from typing import Tuple
from licenseware.uploader_validator import UploaderValidator


class RVToolsUploaderValidator(UploaderValidator): 
    # Overwrite `calculate_quota`, `get_filenames_response` or `get_file_objects_response` if needed
    # Otherwise you can just instantiate the class validator from `UploaderValidator` 
    ...



rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = ['RV', 'Tools'],
    filename_endswith = ['.xls', '.xlsx'],
    ignore_filenames  = ['skip_this_file.csv'],
    required_input_type = &quot;excel&quot;,
    min_rows_number = 1,
    required_sheets = ['tabvInfo', 'tabvCPU', 'tabvHost', 'tabvCluster'],
    required_columns = [
        'VM', 'Host', 'OS', 'Sockets', 'CPUs', 'Model', 'CPU Model',
        'Cluster', '# CPU', '# Cores', 'ESX Version', 'HT Active',
        'Name', 'NumCpuThreads', 'NumCpuCores'
    ]
)


</code></pre>
<p>If parameters provided for validating filenames and contents are not enough
you can also overwrite: <code>calculate_quota</code>, <code>get_filenames_response</code> and <code>get_file_objects_response</code> methods.</p>
<ul>
<li><code>calculate_quota</code>: given a flask request object calculates quota for tenant_id based on current processing units (by default it's using len(files) got from request)</li>
<li><code>get_filenames_response</code> : given a flask request object validates filenames and returns a json response, status code</li>
<li><code>get_file_objects_response</code> : given a flask request object validates filenames and contents and returns a json response, status code</li>
</ul>
<p>Now we have <code>rv_tools_validator</code> as a <code>validator_class</code> and
<code>rv_tools_worker</code> as a <code>worker_function</code>.</p>
<pre><code class="language-py">#uploader.py

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator

from ...worker import rv_tools_worker
from ...validator import rv_tools_validator



rv_tools_uploader = UploaderBuilder(
    name=&quot;RVTools&quot;, 
    uploader_id = 'rv_tools',
    description=&quot;XLSX export from RVTools after scanning your Vmware infrastructure.&quot;, 
    accepted_file_types=['.xls', '.xlsx'],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker
)


</code></pre>
<p>Great! Now we have an uploader defined!</p>
<p>We can later import the uploader in our main file and register it to our defined <code>App</code>.
The registering process will take care of api generation for uploaders.</p>
<pre><code class="language-py">ifmp_app.register_uploader(rv_tools_uploader)
</code></pre>
<p>Of course defining an uploader can be defined in just one file too.</p>
<p><a name="report-declaration"></a></p>
<h1 id="report-declaration"><code>Report</code> declaration</h1>
<p>A <code>Report</code> is composed of one or more <code>report components</code>.
Each report component will inherit from <code>BaseReportComponent</code> class.</p>
<h2 id="creating-the-report-component">Creating the <code>Report component</code></h2>
<p>The following methods will need to be overwrited:</p>
<ul>
<li>
<p><code>get_data</code> : receives a flask request needs to return data for the declared report component;</p>
<ul>
<li>use <code>match_filters = self.get_mongo_match_filters(flask_request)</code> to get default pipeline filters (tenant_id and filters from front-end);</li>
</ul>
</li>
<li>
<p><code>set_attributes</code> : return based on <code>component_type</code> component metadata which is used by front-end to render data received from <code>get_data</code> method;</p>
</li>
<li><code>set_style_attributes</code> : return component style metadata which is used by front-end to apply different css attributes
(width, height, color etc);</li>
</ul>
<p>A <code>NotImplmentedError</code> exception will raise if methods mentioned up are not overwritted.</p>
<pre><code class="language-py">#some_report_component.py

from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import style_attributes as styles
from licenseware.common.constants import icons


class VirtualOverview(BaseReportComponent):

    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type

        super().__init__(**vars(self))


    def get_data(self, flask_request):

        match_filters = self.get_mongo_match_filters(flask_request)

        log.info(match_filters)

        return ['mongo pipeline result']


    def set_attributes(self):

        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&quot;number_of_devices&quot;, icons.SERVERS), 
            (&quot;number_of_databases&quot;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)


        # Or raw dict (same results are achived using the method up)

        attributes = {'series': [
            {
                'value_description': 'Number of devices',
                'value_key': 'number_of_devices',
                'icon': 'ServersIcon'
            },
            {
                'value_description': 'Number of databases',
                'value_key': 'number_of_databases',
                'icon': 'DatabaseIconRounded'
            }
        ]}

        # You can also return attributes
        return attributes


    def set_style_attributes(self):

        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            'width': '1/3'
        }

        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])

        return style_attributes


    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&quot;device_name&quot;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&quot;Device Name&quot;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &quot;column&quot;: &quot;database_name&quot;,
                &quot;allowed_filters&quot;: [
                    &quot;equals&quot;, &quot;contains&quot;, &quot;in_list&quot;
                ],
                &quot;visible_name&quot;: &quot;Database Name&quot;
            }

        ]




virtual_overview = VirtualOverview(
    title=&quot;Overview&quot;,
    component_id=&quot;virtual_overview&quot;,
    component_type='summary'
)


</code></pre>
<p>Now <code>virtual_overview</code> is our <code>report_component</code>.</p>
<p>We can later register the component straight to the <code>App</code> or <code>Report</code></p>
<pre><code class="language-py">ifmp_app.register_report_component(virtual_overview)
</code></pre>
<h2 id="creating-the-report">Creating the <code>Report</code></h2>
<p>The report can hold one or more report components. </p>
<pre><code class="language-py">#report.py

from licenseware.report_builder import ReportBuilder
from ...some_report_component import virtual_overview


virtualization_details_report = ReportBuilder(
    name=&quot;Virtualization Details&quot;,
    report_id=&quot;virtualization_details&quot;,
    description=&quot;This report gives you a detailed view of your virtual infrastructure.&quot;,
    connected_apps=['ifmp-service'],
    report_components=[
        virtual_overview        
    ]
)

</code></pre>
<p>We can later add the report to our main <code>App</code></p>
<pre><code class="language-py">ifmp_app.register_report(virtualization_details_report)
</code></pre>
<p>Reports api will be handled by the <code>ifmp_app</code> instance.</p>
<p><a name="custom-namespaces"></a></p>
<h1 id="custom-namespaces">Custom namespaces</h1>
<p>We are not restricted using just the apis generated from <code>AppBuilder</code> we can add new custom ones to <code>App</code>/<code>ifmp_app</code>.</p>
<pre><code class="language-py">#some_namespace.py

from flask_restx import Namespace, Resource


ns = Namespace(
    name=&quot;Custom&quot;, 
    description=&quot;This is a custom namespace with the app prefix&quot;
)

@ns.route(&quot;/custom-api-route&quot;)
class CustomApiRoute(Resource):    
    @ns.doc(id=&quot;custom&quot;)
    def get(self):
        return &quot;custom-api-route&quot;

</code></pre>
<p>We can later import the namespace created to our <code>main</code> file</p>
<pre><code class="language-py">ifmp_app.add_namespace(custom_ns, path='/ns-prefix')
</code></pre>
<p><code>ifmp_app</code> will make sure it will have the app prefix.</p>
<p>If the custom namespace created is repetead for all apps consider adding it to <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> package.</p>
<p><a name="endpoints-from-simple-functions"></a></p>
<h1 id="endpoints-from-simple-functions">Endpoints from simple functions</h1>
<p>Class <code>EndpointBuilder</code> can be used to generate endpoints from simple functions.
The function name will be used to extract the http method and the route path (<code>get_custom_data_from_mongo</code> &ndash;&gt;
<code>GET</code> http-method, <code>/get_custom_data_from_mongo</code> path-route)</p>
<pre><code class="language-py">#func.py

from licenseware.endpoint_builder import EndpointBuilder

def get_custom_data_from_mongo(flask_request):
    &quot;&quot;&quot; Custom documentation &quot;&quot;&quot;

    # Some logic here

    return &quot;Some data&quot;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)
</code></pre>
<p>The function will receive a flask request as a parameter and will be added to <code>/custom_endpoint/get_custom_data_from_mongo</code></p>
<p>Later in our <code>main</code> file: </p>
<pre><code class="language-py">ifmp_app.register_endpoint(custom_func_endpoint)
</code></pre>
<p><a name="the-main-file"></a></p>
<h1 id="the-main-file">The <code>main</code> file</h1>
<p>In the main file or in <code>create_app</code> builder function (where Flask is instantiated) we can initialize the <code>App</code> with <code>ifmp_app.init_app(app)</code> where <code>app</code> is the Flask instance. </p>
<p>When <code>init_app</code> is invoked all endpoinds defined in <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> will be created and registration information will be sent to registry-service if <code>register=True</code>. You can also initiate the registration to registry-service process with <code>ifmp_app.register_app()</code> </p>
<pre><code class="language-py">
from flask import Flask
from ...app_definition import ifmp_app
from ...uploader import rv_tools_uploader
from ...some_report_component import virtual_overview
from ...report import virtualization_details_report
from ...some_namespace import ns as custom_ns
from ...func import custom_func_endpoint


app = Flask(__name__)


# These can be placed in `app_definition`  

ifmp_app.register_uploader(rv_tools_uploader)
ifmp_app.register_report_component(virtual_overview)
ifmp_app.register_report(virtualization_details_report)
ifmp_app.add_namespace(custom_ns, path='/ns-prefix')
ifmp_app.register_endpoint(custom_func_endpoint)


# Just like any other flask extension
ifmp_app.init_app(app, register=True)    


if __name__ == &quot;__main__&quot;:    
    app.run(port=4000, debug=True)


</code></pre>
<p><a name="licenseware-cli"></a></p>
<h1 id="licenseware-cli">LICENSEWARE CLI</h1>
<p>The licenseware sdk provides also some CLI utilities for quick development.
You can invoke the cli with by typing licenseware in the terminal followed by &ndash;help for docs.</p>
<pre><code>
$ licenseware --help

Usage: licenseware [OPTIONS] COMMAND [ARGS]...

  Useful CLI commands for automatic code generation, files and folders
  creation.

Options:
  --install-completion [bash|zsh|fish|powershell|pwsh]
                                  Install completion for the specified shell.
  --show-completion [bash|zsh|fish|powershell|pwsh]
                                  Show completion for the specified shell, to
                                  copy it or customize the installation.

  --help                          Show this message and exit.

Commands:
  new-app               Make structure for a new app
  new-report            Make structure for a new report
  new-report-component  Make structure for a new report component
  new-uploader          Make structure for a new uploader


</code></pre>
<h2 id="create-the-app-from-cli">Create the app from CLI</h2>
<p>Create the app from the terminal</p>
<pre><code class="language-bash">
licenseware new-app

</code></pre>
<p>The entire app structure will be generated </p>
<pre><code class="language-bash"># The cloned github repository
├── app
│   ├── common
│   │   └── __init__.py
│   ├── controllers
│   │   └── __init__.py
│   ├── __init__.py
│   ├── report_components
│   │   └── __init__.py   # create a new report component with `licenseware new-report-component component_id` 
│   ├── reports
│   │   └── __init__.py   # create a new report with `licenseware new-report report_id`
│   ├── serializers
│   │   └── __init__.py
│   ├── uploaders
│   │   └── __init__.py   # create a new uploader with `licenseware new-uploader uploader_id`
│   ├── utils
│   │    └── __init__.py
│   └── __init__.py       # here the app is instantiated and the uploaders, reports, report_components are registered to the app
├── app.log
├── docker-compose-mongo-redis.yml
├── main_example.py
├── main.py
├── makefile
├── mock_server.py
├── README.md
├── requirements.txt
├── setup.py

</code></pre>
<p>All imports will be handled by the CLI when you create a new uploader, report or report_component from the terminal.</p>
<h2 id="create-a-new-uploader-from-cli">Create a new uploader from CLI</h2>
<p><code>new-uploader</code> needs a uploader id</p>
<pre><code class="language-bash">
licenseware new-uploader rv_tools

</code></pre>
<pre><code>.uploaders
├── __init__.py
└── rv_tools
    ├── __init__.py
    ├── validator.py
    └── worker.py
</code></pre>
<p>Uploader id will be <code>rv_tools</code>. Each uploader has a validator and a worker.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.</p>
<h2 id="create-a-new-report-from-cli">Create a new report from CLI</h2>
<p><code>new-report</code> needs a report id</p>
<pre><code class="language-bash">
licenseware new-report virtualization_details

</code></pre>
<pre><code>.reports
├── __init__.py
└── virtualization_details
    ├── __init__.py
    └── virtualization_details.py
</code></pre>
<p>Report id will be <code>virtualization_details</code>.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.</p>
<h2 id="create-a-new-report-component-from-cli">Create a new report component from CLI</h2>
<p><code>new-report-component</code> needs a component id and a component type</p>
<pre><code class="language-bash">
licenseware new-report-component virtual_overview summary

</code></pre>
<pre><code>.report_components
├── __init__.py
└── virtual_overview
    ├── __init__.py
    └── virtual_overview.py
</code></pre>
<p>Component id will be <code>virtual_overview</code> and it's component type will be <code>summary</code>.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.</p>
<h1 id="load-testing">Load testing</h1>
<h2 id="todo">TODO</h2>
<p><a href="https://github.com/americanexpress/baton">baton docs</a></p>
<pre><code class="language-bash">baton -u http://localhost:4000 -c 10 -r 10000
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
# Licenseware SDK

This is the licenseware **Python3** sdk useful for creating apps quickly. The SDK handles the repetetive actions needed for creating an app (file uploads/validation, background events, api routes and more). It helps you focus on processsing the files provided and creating the reports based on processed data.  



# Contents

1. [Quickstart](#quickstart)
2. [What is an `App`?](#what-is-an-app)
3. [Set environment variables](#set-environment-variables)
4. [`App` declaration](#app-declaration)
5. [`Uploader` declaration](#uploader-declaration)
6. [`Report` declaration](#report-declaration)
7. [Custom namespaces](#custom-namespaces)
8. [Endpoints from simple functions](#endpoints-from-simple-functions)
9. [The `main` file](#the-main-file)
10. [Licenseware CLI](#licenseware-cli) 



&lt;a name=&#34;quickstart&#34;&gt;&lt;/a&gt;
# QUICKSTART 


## Install Licenseware SDK 

Install latest update for this package using the following pip command:
```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git

```

Install from a specific branch

```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git@branch_name

```

Install from a specific tag

```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git@tag_name

```

You can use `git+ssh` if you have ssh keys configured. 
Uninstall with `pip3 uninstall licenseware`.


## How to create a release

- In `setup.py` update the package version; 
- Create a tag with that version ex: `git tag -a v0.0.11`;
- You can list available tags with `git tag -n`;
- Push created tag with `git push --tags`

Now you use pip to install it from that specific tag:

```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-python3.git@v0.0.11

```

If you want to add more details regarding this package release you can `Create a new release`

- Click the link `Releases`;
- Click `Draft a new release`;
- Click `Tags`;
- Select latest tag version name;
- Add title and description for the release;

![](pics/release.gif)

Optionally you can create a wheel for this package:
```bash

python3 setup.py bdist_wheel sdist

```

And add it to binaries on the release.


Bellow is a full working example of almost all features the sdk provides.

Start the services in the following order:

1. `make up` - mongo and redis;
2. `make mock` - mock dependency server for our app;
3. `make dev` - start the app server (`make prod` to start it with uwsgi);
4. `make worker` - start the background worker.


```py
from dotenv import load_dotenv

load_dotenv()  

from flask import Flask
from flask_restx import Namespace, Resource
from marshmallow import Schema, fields

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import (envs, filters, flags, icons,
                                              states)
from licenseware.endpoint_builder import EndpointBuilder
from licenseware.notifications import notify_upload_status
from licenseware.report_builder import ReportBuilder
from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import styles

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator
from licenseware.utils.logger import log



app = Flask(__name__)


# APP

ifmp_app = AppBuilder(
    name = &#39;Infrastructure Mapper&#39;,
    description = &#39;Overview of devices and networks&#39;,
    flags = [flags.BETA]
)


# UPLOADERS



# Here is the worker function 
# which will process the files in the background
def rv_tools_worker(event_data):
    
    # Event data will contain the following information
    # event_data = {
    #     &#39;tenant_id&#39;: &#39;the tenant_id from request&#39;,
    #     &#39;filepaths&#39;: &#39;absolute file paths to the files uploaded&#39;,
    #     &#39;uploader_id&#39;: &#39;the uploader id in our case rv_tools&#39;
    #     &#39;headers&#39;:  &#39;flask request headers&#39;,
    #     &#39;json&#39;:  &#39;flask request json data&#39;,
    # }
    
    log.info(&#34;Starting working&#34;)
    notify_upload_status(event_data, status=states.RUNNING)
    log.debug(event_data) # here add the processing file logic
    notify_upload_status(event_data, status=states.IDLE)
    log.info(&#34;Finished working&#34;)
    



# Here we are defining the validation required for each upload
# If overwriting bellow mentioned methods is not necessary you can use `UploaderValidator` directly 

class RVToolsUploaderValidator(UploaderValidator): 
    # If necessary you can overwrite bellow mentioned methods
    ...
    
    # def calculate_quota(self, flask_request) -&gt; Tuple[dict, int]:
    # responsible for calculating quota based on tenant_id and returning a json response, status code 
    # ...
    
    # def get_filenames_response(self, flask_request): 
    # responsible for validating filenames and returning a json response, status code
    # ...
    
    # def get_file_objects_response(self, flask_request): 
    #   responsible for validating filenames, their contents and returning a json response, status code
    # ...
    
    

rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = [&#39;RV&#39;, &#39;Tools&#39;],
    filename_endswith = [&#39;.xls&#39;, &#39;.xlsx&#39;],
    ignore_filenames  = [&#39;skip_this_file.csv&#39;],
    required_input_type = &#34;excel&#34;,
    min_rows_number = 1,
    required_sheets = [&#39;tabvInfo&#39;, &#39;tabvCPU&#39;, &#39;tabvHost&#39;, &#39;tabvCluster&#39;],
    required_columns = [
        &#39;VM&#39;, &#39;Host&#39;, &#39;OS&#39;, &#39;Sockets&#39;, &#39;CPUs&#39;, &#39;Model&#39;, &#39;CPU Model&#39;,
        &#39;Cluster&#39;, &#39;# CPU&#39;, &#39;# Cores&#39;, &#39;ESX Version&#39;, &#39;HT Active&#39;,
        &#39;Name&#39;, &#39;NumCpuThreads&#39;, &#39;NumCpuCores&#39;
    ]
)

# Here we are creating the uploader 
# Notice we are providing the the validator created up to `validator_class` parameter
# `worker_function` will be called when `uploader_id` is triggered
# The `uploader_id` event is triggered when files are uploaded to `/uploads/uploader_id/files` route

rv_tools_uploader = UploaderBuilder(
    name=&#34;RVTools&#34;, 
    uploader_id = &#39;rv_tools&#39;,
    description=&#34;XLSX export from RVTools after scanning your Vmware infrastructure.&#34;, 
    accepted_file_types=[&#39;.xls&#39;, &#39;.xlsx&#39;],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker,
    quota_units = 1
)

# Here we are:
# - adding the uploader to the main app (uploaders list)
# - sending uploader information to registry-service
ifmp_app.register_uploader(rv_tools_uploader)




# REPORTS


class VirtualOverview(BaseReportComponent):
            
    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type
        
        super().__init__(**vars(self))
        
        
    def get_data(self, flask_request):
        
        match_filters = self.get_mongo_match_filters(flask_request)
        
        log.info(match_filters)

        return [&#39;mongo pipeline result&#39;]
    
    
    def set_attributes(self):
        
        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&#34;number_of_devices&#34;, icons.SERVERS), 
            (&#34;number_of_databases&#34;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)
        
        
        # Or raw dict (same results are achived using the method up)
        
        attributes = {&#39;series&#39;: [
            {
                &#39;value_description&#39;: &#39;Number of devices&#39;,
                &#39;value_key&#39;: &#39;number_of_devices&#39;,
                &#39;icon&#39;: &#39;ServersIcon&#39;
            },
            {
                &#39;value_description&#39;: &#39;Number of databases&#39;,
                &#39;value_key&#39;: &#39;number_of_databases&#39;,
                &#39;icon&#39;: &#39;DatabaseIconRounded&#39;
            }
        ]}
        
        # You can also return attributes
        return attributes
        
        
    def set_style_attributes(self):
        
        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            &#39;width&#39;: &#39;1/3&#39;
        }
        
        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])
        
        return style_attributes
    
    
    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&#34;device_name&#34;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&#34;Device Name&#34;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &#34;column&#34;: &#34;database_name&#34;,
                &#34;allowed_filters&#34;: [
                    &#34;equals&#34;, &#34;contains&#34;, &#34;in_list&#34;
                ],
                &#34;visible_name&#34;: &#34;Database Name&#34;
            }
        
        ]
        


virtual_overview = VirtualOverview(
    title=&#34;Overview&#34;,
    component_id=&#34;virtual_overview&#34;,
    component_type=&#39;summary&#39;
)

# TODO raise component_id conflict
# Register component to registry-service (to act as a first class citizen)
ifmp_app.register_report_component(virtual_overview)



# Component order is determined by it&#39;s position in the list
report_components=[
    virtual_overview       
]


# Define a report wich holds one or more report components
virtualization_details_report = ReportBuilder(
    name=&#34;Virtualization Details&#34;,
    report_id=&#34;virtualization_details&#34;,
    description=&#34;This report gives you a detailed view of your virtual infrastructure. Deep dive into the infrastructure topology, identify devices with missing host details and capping rules for licensing.&#34;,
    connected_apps=[&#39;ifmp-service&#39;],
    report_components=report_components
)


ifmp_app.register_report(virtualization_details_report)






# CUSTOM RESTX NAMESPACES
# We can add also custom namespaces to main IFMP Api

custom_ns = Namespace(
    name=&#34;Custom&#34;, 
    description=&#34;This is a custom namespace with the app prefix&#34;
)

@custom_ns.route(&#34;/custom-api-route&#34;)
class CustomApiRoute(Resource):    
    @custom_ns.doc(&#34;custom&#34;)
    def get(self):
        return &#34;custom-api-route&#34;
    
# Add it to main app 
# it will have the same namespace prefix /ifmp/v1/ + ns-prefix/custom-api-route
ifmp_app.add_namespace(custom_ns, path=&#39;/ns-prefix&#39;)

# If the namespace defined up it&#39;s used on all apps 
# add it to licenseware sdk in app_builder default routes



# EndpointBuilder

# Endpoints can be generated from functions or marshmellow schemas
# add http method as a prefix to schema or function handler (get_some_data, PostDeviceDataSchema etc)

# Here we are using a function to create an endpoint like /custom_endpoint/custom_data_from_mongo

def get_custom_data_from_mongo(flask_request):
    &#34;&#34;&#34; Custom documentation &#34;&#34;&#34;
    
    # Some logic here

    return &#34;Some data&#34;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)

ifmp_app.register_endpoint(custom_func_endpoint)

# Here we are using a schema to generate an endpoint

class GetDeviceData(Schema):
    
    class Meta:
        collection_name = envs.MONGO_COLLECTION_DATA_NAME
    
    tenant_id = fields.Str(required=False)
    updated_at = fields.Str(required=False)
    name = fields.Str(required=True)
    occupation = fields.Str(required=False)
    
    
custom_schema_endpoint = EndpointBuilder(GetDeviceData)


ifmp_app.register_endpoint(custom_schema_endpoint)


# Call init_app in the flask function factory 
ifmp_app.init_app(app)


if __name__ == &#34;__main__&#34;:   
    
    # Register app to registry-service
    ifmp_app.register_app()
    
    app.run(port=4000, debug=True)


```


Make commands:

- `make up` and  `make down` - start and stop mongo and redis databases;
- `make mock` - start mock server which app will use for authentication, registry-service or other external services dependencies;
- `make dev` - start application with hot reload;
- `make worker` - start dramatiq worker;
- `make test` - run all unit tests.
- `make dev-docs` - this command will start a pdoc3 http server use for viewing and updating documentation for the app created;
- `make docs` - this command will generate html docs based on docstrings provided in the app;
- `make dev-sdk-docs` - this command will start a pdoc3 http server use for viewing and updating licenseware sdk documentation for the app created;
- `make sdk-docs` - this command will generate html docs based on docstrings provided in the app;

Documentation generated can be added later to github pages.

See more about documentation creation here [`pdoc3`](https://pdoc3.github.io/pdoc/).



&lt;a name=&#34;what-is-an-app&#34;&gt;&lt;/a&gt;
# What is an `App`?


Each Licenseware `App`/`Service` is responsible for:

- processing files submitted by the user;
- creating custom reports based on processed data from files. 


Each **APP** has:

- one or more uploaders
- one or more reports 
- one or more report components


Each **UPLOADER** has:

- one file validator class
- one file processing/worker function


Each **REPORT** has:

- one or more report components
- report components can be attached either to app builder instance or to report builder instance


Each **REPORT COMPONENT** has:

- one get_data method;
- one url where data can be accessed;


&lt;a name=&#34;set-environment-variables&#34;&gt;&lt;/a&gt;
# Set environment variables


Fist make sure you have set the environment variables:

```bash
#.env
DEBUG=true
ENVIRONMENT=local
PERSONAL_SUFFIX=_alin


FLASK_APP=main:app

APP_ID=ifmp
APP_HOST=http://localhost:5000

LWARE_IDENTITY_USER=John
LWARE_IDENTITY_PASSWORD=secret

AUTH_SERVICE_URL=http://localhost:5000/auth
AUTH_SERVICE_USERS_URL_PATH=/users
AUTH_SERVICE_MACHINES_URL_PATH=/machines

REGISTRY_SERVICE_URL=http://localhost:5000/registry-service

FILE_UPLOAD_PATH=/tmp/lware

MONGO_ROOT_USERNAME=Alin
MONGO_ROOT_PASSWORD=secret
MONGO_HOSTNAME=localhost
MONGO_PORT=27017
MONGO_DATABASE_NAME=db
MONGO_CONNECTION_STRING=mongodb://${MONGO_HOSTNAME}:${MONGO_PORT}/${MONGO_DATABASE_NAME}


REDIS_HOST=redis_db_sdk
REDIS_PORT=6379

```

Start `redis` and `mongo` databases:

```bash
make up
```








&lt;a name=&#34;app-declaration&#34;&gt;&lt;/a&gt;
# `App` declaration


`AppBuilder` class will be used to define our `App`. 
This class will handle: 

- automatic api generation;
- sending to registry service information about `uploader_builder`, `report_builder`, `report_components` and others if needed.


```py
#app_definition.py

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import flags


ifmp_app = AppBuilder(
    name = &#39;Infrastructure Mapper&#39;,
    description = &#39;Overview of devices and networks&#39;,
    flags = [flags.BETA]
)


```

The `ifmp_app` instance is now ready to attach other uploaders, reports, report components (or others) using *ifmp_app.register_X* methods.



&lt;a name=&#34;uploader-declaration&#34;&gt;&lt;/a&gt;
# `Uploader` declaration


The uploader is responsible for:

- validating files received from user;
- calculating quota for user and sending the appropiate response if quota exceded;
- uploading files to disk;
- triggering `worker_function` to process the files in the background; 

Each uploader needs a `validator_class` and a `worker_function`.  


## Creating the `worker_function`

Here is the worker function which will process the files in the background.

```py
#worker.py

from licenseware.notification import notify_upload_status
from licenseware.utils.logger import log

def rv_tools_worker(event_data):
    log.info(&#34;Starting working&#34;)
    notify_upload_status(event_data, status=states.RUNNING)
    log.debug(event_data) # here add the processing file logic
    notify_upload_status(event_data, status=states.IDLE)
    log.info(&#34;Finished working&#34;)
    
```

The `event_data` will be a dictionary with the following contents:

```js

{
    &#39;tenant_id&#39;: &#34;uuid4 tenant id from flask request.headers&#34;,
    &#39;filepaths&#39;: [&#34;absolute/path/to/files/uploaded&#34;],
    &#39;uploader_id&#39;: &#39;the uploader id in our case rv_tools&#39;
    &#39;headers&#39;:  &#39;flask request.headers&#39;,
    &#39;json&#39;:  &#39;flask request.json&#39;,
}

```

Based on given `event_data` the `worker_function` will process the files.


## Creating the `validator_class`

Here we are defining the validation and quota calculation required for each upload.

Create a new class which inherits from `UploaderValidator` and overwrite `calculate_quota` function.
Method `calculate_quota` receives a flask request as a parameter which can be used to extract files and tenant_id needed for quota calculation.

Finally, instantiate the validator class with the required parameters needed for validation.

```py
#validator.py

from typing import Tuple
from licenseware.uploader_validator import UploaderValidator


class RVToolsUploaderValidator(UploaderValidator): 
    # Overwrite `calculate_quota`, `get_filenames_response` or `get_file_objects_response` if needed
    # Otherwise you can just instantiate the class validator from `UploaderValidator` 
    ...
    
    
    
rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = [&#39;RV&#39;, &#39;Tools&#39;],
    filename_endswith = [&#39;.xls&#39;, &#39;.xlsx&#39;],
    ignore_filenames  = [&#39;skip_this_file.csv&#39;],
    required_input_type = &#34;excel&#34;,
    min_rows_number = 1,
    required_sheets = [&#39;tabvInfo&#39;, &#39;tabvCPU&#39;, &#39;tabvHost&#39;, &#39;tabvCluster&#39;],
    required_columns = [
        &#39;VM&#39;, &#39;Host&#39;, &#39;OS&#39;, &#39;Sockets&#39;, &#39;CPUs&#39;, &#39;Model&#39;, &#39;CPU Model&#39;,
        &#39;Cluster&#39;, &#39;# CPU&#39;, &#39;# Cores&#39;, &#39;ESX Version&#39;, &#39;HT Active&#39;,
        &#39;Name&#39;, &#39;NumCpuThreads&#39;, &#39;NumCpuCores&#39;
    ]
)


```

If parameters provided for validating filenames and contents are not enough 
you can also overwrite: `calculate_quota`, `get_filenames_response` and `get_file_objects_response` methods.

- `calculate_quota`: given a flask request object calculates quota for tenant_id based on current processing units (by default it&#39;s using len(files) got from request)
- `get_filenames_response` : given a flask request object validates filenames and returns a json response, status code
- `get_file_objects_response` : given a flask request object validates filenames and contents and returns a json response, status code


Now we have `rv_tools_validator` as a `validator_class` and  `rv_tools_worker` as a `worker_function`.


```py
#uploader.py

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator

from ...worker import rv_tools_worker
from ...validator import rv_tools_validator



rv_tools_uploader = UploaderBuilder(
    name=&#34;RVTools&#34;, 
    uploader_id = &#39;rv_tools&#39;,
    description=&#34;XLSX export from RVTools after scanning your Vmware infrastructure.&#34;, 
    accepted_file_types=[&#39;.xls&#39;, &#39;.xlsx&#39;],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker
)


```

Great! Now we have an uploader defined!

We can later import the uploader in our main file and register it to our defined `App`.
The registering process will take care of api generation for uploaders.

```py
ifmp_app.register_uploader(rv_tools_uploader)
```

Of course defining an uploader can be defined in just one file too.













&lt;a name=&#34;report-declaration&#34;&gt;&lt;/a&gt;
# `Report` declaration


A `Report` is composed of one or more `report components`. 
Each report component will inherit from `BaseReportComponent` class.


## Creating the `Report component`

The following methods will need to be overwrited:

- `get_data` : receives a flask request needs to return data for the declared report component;
    - use `match_filters = self.get_mongo_match_filters(flask_request)` to get default pipeline filters (tenant_id and filters from front-end);

- `set_attributes` : return based on `component_type` component metadata which is used by front-end to render data received from `get_data` method;
- `set_style_attributes` : return component style metadata which is used by front-end to apply different css attributes  (width, height, color etc);

A `NotImplmentedError` exception will raise if methods mentioned up are not overwritted.


```py
#some_report_component.py

from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import style_attributes as styles
from licenseware.common.constants import icons


class VirtualOverview(BaseReportComponent):
            
    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type
        
        super().__init__(**vars(self))
        
        
    def get_data(self, flask_request):
        
        match_filters = self.get_mongo_match_filters(flask_request)
        
        log.info(match_filters)

        return [&#39;mongo pipeline result&#39;]
    
    
    def set_attributes(self):
        
        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&#34;number_of_devices&#34;, icons.SERVERS), 
            (&#34;number_of_databases&#34;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)
        
        
        # Or raw dict (same results are achived using the method up)
        
        attributes = {&#39;series&#39;: [
            {
                &#39;value_description&#39;: &#39;Number of devices&#39;,
                &#39;value_key&#39;: &#39;number_of_devices&#39;,
                &#39;icon&#39;: &#39;ServersIcon&#39;
            },
            {
                &#39;value_description&#39;: &#39;Number of databases&#39;,
                &#39;value_key&#39;: &#39;number_of_databases&#39;,
                &#39;icon&#39;: &#39;DatabaseIconRounded&#39;
            }
        ]}
        
        # You can also return attributes
        return attributes
        
        
    def set_style_attributes(self):
        
        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            &#39;width&#39;: &#39;1/3&#39;
        }
        
        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])
        
        return style_attributes


    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&#34;device_name&#34;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&#34;Device Name&#34;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &#34;column&#34;: &#34;database_name&#34;,
                &#34;allowed_filters&#34;: [
                    &#34;equals&#34;, &#34;contains&#34;, &#34;in_list&#34;
                ],
                &#34;visible_name&#34;: &#34;Database Name&#34;
            }
        
        ]
        
    
        

virtual_overview = VirtualOverview(
    title=&#34;Overview&#34;,
    component_id=&#34;virtual_overview&#34;,
    component_type=&#39;summary&#39;
)


```

Now `virtual_overview` is our `report_component`.

We can later register the component straight to the `App` or `Report`
```py
ifmp_app.register_report_component(virtual_overview)
```

## Creating the `Report`

The report can hold one or more report components. 


```py
#report.py

from licenseware.report_builder import ReportBuilder
from ...some_report_component import virtual_overview


virtualization_details_report = ReportBuilder(
    name=&#34;Virtualization Details&#34;,
    report_id=&#34;virtualization_details&#34;,
    description=&#34;This report gives you a detailed view of your virtual infrastructure.&#34;,
    connected_apps=[&#39;ifmp-service&#39;],
    report_components=[
        virtual_overview        
    ]
)

```

We can later add the report to our main `App`

```py
ifmp_app.register_report(virtualization_details_report)
```

Reports api will be handled by the `ifmp_app` instance.






&lt;a name=&#34;custom-namespaces&#34;&gt;&lt;/a&gt;
# Custom namespaces


We are not restricted using just the apis generated from `AppBuilder` we can add new custom ones to `App`/`ifmp_app`.



```py
#some_namespace.py

from flask_restx import Namespace, Resource


ns = Namespace(
    name=&#34;Custom&#34;, 
    description=&#34;This is a custom namespace with the app prefix&#34;
)

@ns.route(&#34;/custom-api-route&#34;)
class CustomApiRoute(Resource):    
    @ns.doc(id=&#34;custom&#34;)
    def get(self):
        return &#34;custom-api-route&#34;

```

We can later import the namespace created to our `main` file

```py
ifmp_app.add_namespace(custom_ns, path=&#39;/ns-prefix&#39;)
```

`ifmp_app` will make sure it will have the app prefix.

If the custom namespace created is repetead for all apps consider adding it to `app_builder` package.







&lt;a name=&#34;endpoints-from-simple-functions&#34;&gt;&lt;/a&gt;
# Endpoints from simple functions


Class `EndpointBuilder` can be used to generate endpoints from simple functions.
The function name will be used to extract the http method and the route path (`get_custom_data_from_mongo` --&gt;
`GET` http-method, `/get_custom_data_from_mongo` path-route)

```py
#func.py

from licenseware.endpoint_builder import EndpointBuilder

def get_custom_data_from_mongo(flask_request):
    &#34;&#34;&#34; Custom documentation &#34;&#34;&#34;
    
    # Some logic here

    return &#34;Some data&#34;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)
```

The function will receive a flask request as a parameter and will be added to `/custom_endpoint/get_custom_data_from_mongo`

Later in our `main` file: 
```py
ifmp_app.register_endpoint(custom_func_endpoint)
```









&lt;a name=&#34;the-main-file&#34;&gt;&lt;/a&gt;
# The `main` file


In the main file or in `create_app` builder function (where Flask is instantiated) we can initialize the `App` with `ifmp_app.init_app(app)` where `app` is the Flask instance. 

When `init_app` is invoked all endpoinds defined in `app_builder` will be created and registration information will be sent to registry-service if `register=True`. You can also initiate the registration to registry-service process with `ifmp_app.register_app()` 


```py

from flask import Flask
from ...app_definition import ifmp_app
from ...uploader import rv_tools_uploader
from ...some_report_component import virtual_overview
from ...report import virtualization_details_report
from ...some_namespace import ns as custom_ns
from ...func import custom_func_endpoint


app = Flask(__name__)


# These can be placed in `app_definition`  

ifmp_app.register_uploader(rv_tools_uploader)
ifmp_app.register_report_component(virtual_overview)
ifmp_app.register_report(virtualization_details_report)
ifmp_app.add_namespace(custom_ns, path=&#39;/ns-prefix&#39;)
ifmp_app.register_endpoint(custom_func_endpoint)


# Just like any other flask extension
ifmp_app.init_app(app, register=True)    
    

if __name__ == &#34;__main__&#34;:    
    app.run(port=4000, debug=True)


```




&lt;a name=&#34;licenseware-cli&#34;&gt;&lt;/a&gt;
# LICENSEWARE CLI

The licenseware sdk provides also some CLI utilities for quick development. 
You can invoke the cli with by typing licenseware in the terminal followed by --help for docs.

```

$ licenseware --help

Usage: licenseware [OPTIONS] COMMAND [ARGS]...

  Useful CLI commands for automatic code generation, files and folders
  creation.

Options:
  --install-completion [bash|zsh|fish|powershell|pwsh]
                                  Install completion for the specified shell.
  --show-completion [bash|zsh|fish|powershell|pwsh]
                                  Show completion for the specified shell, to
                                  copy it or customize the installation.

  --help                          Show this message and exit.

Commands:
  new-app               Make structure for a new app
  new-report            Make structure for a new report
  new-report-component  Make structure for a new report component
  new-uploader          Make structure for a new uploader


```

## Create the app from CLI 

Create the app from the terminal
```bash

licenseware new-app

``` 

The entire app structure will be generated 

```bash
# The cloned github repository
├── app
│   ├── common
│   │   └── __init__.py
│   ├── controllers
│   │   └── __init__.py
│   ├── __init__.py
│   ├── report_components
│   │   └── __init__.py   # create a new report component with `licenseware new-report-component component_id` 
│   ├── reports
│   │   └── __init__.py   # create a new report with `licenseware new-report report_id`
│   ├── serializers
│   │   └── __init__.py
│   ├── uploaders
│   │   └── __init__.py   # create a new uploader with `licenseware new-uploader uploader_id`
│   ├── utils
│   │    └── __init__.py
│   └── __init__.py       # here the app is instantiated and the uploaders, reports, report_components are registered to the app
├── app.log
├── docker-compose-mongo-redis.yml
├── main_example.py
├── main.py
├── makefile
├── mock_server.py
├── README.md
├── requirements.txt
├── setup.py

```

All imports will be handled by the CLI when you create a new uploader, report or report_component from the terminal.


## Create a new uploader from CLI 

`new-uploader` needs a uploader id

```bash

licenseware new-uploader rv_tools

``` 

```
.uploaders
├── __init__.py
└── rv_tools
    ├── __init__.py
    ├── validator.py
    └── worker.py
```

Uploader id will be `rv_tools`. Each uploader has a validator and a worker. 
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.




## Create a new report from CLI 

`new-report` needs a report id

```bash

licenseware new-report virtualization_details

``` 

```
.reports
├── __init__.py
└── virtualization_details
    ├── __init__.py
    └── virtualization_details.py
```

Report id will be `virtualization_details`.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.




## Create a new report component from CLI 

`new-report-component` needs a component id and a component type

```bash

licenseware new-report-component virtual_overview summary

``` 

```
.report_components
├── __init__.py
└── virtual_overview
    ├── __init__.py
    └── virtual_overview.py
```

Component id will be `virtual_overview` and it&#39;s component type will be `summary`.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.







# Load testing

## TODO

[baton docs](https://github.com/americanexpress/baton)


```bash
baton -u http://localhost:4000 -c 10 -r 10000
```


&#39;&#39;&#39;


from dotenv import load_dotenv

load_dotenv()  </code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code></dt>
<dd>
<div class="desc"><p>In the <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> package we define the <code>app</code> and build the api …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.auth" href="auth/index.html">licenseware.auth</a></code></dt>
<dd>
<div class="desc"><p>Here is the authentification class for machines and services.
Authentification credentials will be taken from <code>.env</code> file …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.cli" href="cli/index.html">licenseware.cli</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.common" href="common/index.html">licenseware.common</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.decorators" href="decorators/index.html">licenseware.decorators</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.editable_table" href="editable_table/index.html">licenseware.editable_table</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.endpoint_builder" href="endpoint_builder/index.html">licenseware.endpoint_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.mongodata" href="mongodata/index.html">licenseware.mongodata</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.namespace_generator" href="namespace_generator/index.html">licenseware.namespace_generator</a></code></dt>
<dd>
<div class="desc"><p>This module makes available the <code>namespace</code> decorator
which can be used to generate flask_restx namespace from marshmallow schema …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.notifications" href="notifications/index.html">licenseware.notifications</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.quota" href="quota/index.html">licenseware.quota</a></code></dt>
<dd>
<div class="desc"><p>This package is reponsible for updating the quota per <code>user_id</code> at each upload …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.registry_service" href="registry_service/index.html">licenseware.registry_service</a></code></dt>
<dd>
<div class="desc"><p>All calls to registry service should be added in this package</p></div>
</dd>
<dt><code class="name"><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.resources" href="resources/index.html">licenseware.resources</a></code></dt>
<dd>
<div class="desc"><p>Here are package static files that are used by the cli to generate files and folders.
We are using jinja2 to fill variables from files …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.tenants" href="tenants/index.html">licenseware.tenants</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.uploader_validator" href="uploader_validator/index.html">licenseware.uploader_validator</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.utils" href="utils/index.html">licenseware.utils</a></code></dt>
<dd>
<div class="desc"><p>In this package you will find various functions and classes that can be used when needed.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#licenseware-sdk">Licenseware SDK</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#quickstart">QUICKSTART</a><ul>
<li><a href="#install-licenseware-sdk">Install Licenseware SDK</a></li>
<li><a href="#how-to-create-a-release">How to create a release</a></li>
</ul>
</li>
<li><a href="#what-is-an-app">What is an App?</a></li>
<li><a href="#set-environment-variables">Set environment variables</a></li>
<li><a href="#app-declaration">App declaration</a></li>
<li><a href="#uploader-declaration">Uploader declaration</a><ul>
<li><a href="#creating-the-worker_function">Creating the worker_function</a></li>
<li><a href="#creating-the-validator_class">Creating the validator_class</a></li>
</ul>
</li>
<li><a href="#report-declaration">Report declaration</a><ul>
<li><a href="#creating-the-report-component">Creating the Report component</a></li>
<li><a href="#creating-the-report">Creating the Report</a></li>
</ul>
</li>
<li><a href="#custom-namespaces">Custom namespaces</a></li>
<li><a href="#endpoints-from-simple-functions">Endpoints from simple functions</a></li>
<li><a href="#the-main-file">The main file</a></li>
<li><a href="#licenseware-cli">LICENSEWARE CLI</a><ul>
<li><a href="#create-the-app-from-cli">Create the app from CLI</a></li>
<li><a href="#create-a-new-uploader-from-cli">Create a new uploader from CLI</a></li>
<li><a href="#create-a-new-report-from-cli">Create a new report from CLI</a></li>
<li><a href="#create-a-new-report-component-from-cli">Create a new report component from CLI</a></li>
</ul>
</li>
<li><a href="#load-testing">Load testing</a><ul>
<li><a href="#todo">TODO</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code></li>
<li><code><a title="licenseware.auth" href="auth/index.html">licenseware.auth</a></code></li>
<li><code><a title="licenseware.cli" href="cli/index.html">licenseware.cli</a></code></li>
<li><code><a title="licenseware.common" href="common/index.html">licenseware.common</a></code></li>
<li><code><a title="licenseware.decorators" href="decorators/index.html">licenseware.decorators</a></code></li>
<li><code><a title="licenseware.editable_table" href="editable_table/index.html">licenseware.editable_table</a></code></li>
<li><code><a title="licenseware.endpoint_builder" href="endpoint_builder/index.html">licenseware.endpoint_builder</a></code></li>
<li><code><a title="licenseware.mongodata" href="mongodata/index.html">licenseware.mongodata</a></code></li>
<li><code><a title="licenseware.namespace_generator" href="namespace_generator/index.html">licenseware.namespace_generator</a></code></li>
<li><code><a title="licenseware.notifications" href="notifications/index.html">licenseware.notifications</a></code></li>
<li><code><a title="licenseware.quota" href="quota/index.html">licenseware.quota</a></code></li>
<li><code><a title="licenseware.registry_service" href="registry_service/index.html">licenseware.registry_service</a></code></li>
<li><code><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code></li>
<li><code><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code></li>
<li><code><a title="licenseware.resources" href="resources/index.html">licenseware.resources</a></code></li>
<li><code><a title="licenseware.tenants" href="tenants/index.html">licenseware.tenants</a></code></li>
<li><code><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code></li>
<li><code><a title="licenseware.uploader_validator" href="uploader_validator/index.html">licenseware.uploader_validator</a></code></li>
<li><code><a title="licenseware.utils" href="utils/index.html">licenseware.utils</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>