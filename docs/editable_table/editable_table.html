<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>licenseware.editable_table.editable_table API documentation</title>
<meta name="description" content="EditableTable provided in this package is used to generate table metadata from a marshmallow Schema â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>licenseware.editable_table.editable_table</code></h1>
</header>
<section id="section-intro">
<p>EditableTable provided in this package is used to generate table metadata from a marshmallow Schema</p>
<p>From the schema provided <code><a title="licenseware.editable_table.editable_table.EditableTable" href="#licenseware.editable_table.editable_table.EditableTable">EditableTable</a>(schema).specs</code> will return a list of editable tables metadata similar to this:</p>
<pre><code class="language-js">[
  {
    &quot;component_id&quot;: &quot;ifmp_devicetables&quot;,
    &quot;url&quot;: &quot;http://localhost:5000/ifmp/devicetable&quot;,
    &quot;path&quot;: &quot;/devicetable&quot;,
    &quot;order&quot;: 1,
    &quot;style_attributes&quot;: {
      &quot;width&quot;: &quot;full&quot;
    },
    &quot;title&quot;: &quot;All devicetables&quot;,
    &quot;type&quot;: &quot;editable_table&quot;,
    &quot;columns&quot;: [
      {
        &quot;name&quot;: &quot;Id&quot;,
        &quot;prop&quot;: &quot;_id&quot;,
        &quot;editable&quot;: false,
        &quot;type&quot;: &quot;string&quot;,
        &quot;values&quot;: null,
        &quot;required&quot;: false,
        &quot;visible&quot;: false,
        &quot;entities_url&quot;: &quot;http://localhost:5000/ifmp/devicetable?_id=%7Bentity_id%7D&quot;,
        &quot;entities_path&quot;: &quot;/devicetable?_id=%7Bentity_id%7D&quot;
      },
      {
        &quot;name&quot;: &quot;Is Parent To&quot;,
        &quot;prop&quot;: &quot;is_parent_to&quot;,
        &quot;editable&quot;: true,
        &quot;type&quot;: &quot;entity&quot;,
        &quot;values&quot;: null,
        &quot;required&quot;: false,
        &quot;visible&quot;: false,
        &quot;entities_url&quot;: &quot;http://localhost:5000/ifmp/devicetable?distinct_key=name&amp;foreign_key=name&amp;_id=%7Bentity_id%7D&quot;,
        &quot;entities_path&quot;: &quot;/devicetable?distinct_key=name&amp;foreign_key=name&amp;_id=%7Bentity_id%7D&quot;
      },
      {
        &quot;name&quot;: &quot;Device Type&quot;,
        &quot;prop&quot;: &quot;device_type&quot;,
        &quot;editable&quot;: false,
        &quot;type&quot;: &quot;enum&quot;,
        &quot;values&quot;: [
          &quot;Cluster&quot;,
          &quot;Domain&quot;,
          &quot;Physical&quot;,
          &quot;Pool&quot;,
          &quot;Unknown&quot;,
          &quot;Virtual&quot;
        ],
        &quot;required&quot;: true,
        &quot;visible&quot;: false,
        &quot;entities_url&quot;: &quot;http://localhost:5000/ifmp/devicetable?_id=%7Bentity_id%7D&quot;,
        &quot;entities_path&quot;: &quot;/devicetable?_id=%7Bentity_id%7D&quot;
      },
    ]
  }
]

</code></pre>
<p>From the information provided up the front-end will know how to render each column based on: datatype(type), editable, required, visible parameters.</p>
<h1 id="todo-add-pagination">TODO add pagination</h1>
<p>By making a get request to the root url (<code>"url": "http://localhost:5000/ifmp/devicetable"</code>) all data will be returned from mongo. </p>
<p>A get request with the <code>_id</code> query parameter will return the coresponding document from mongo.
<code>"entities_url": "http://localhost:5000/ifmp/devicetable?_id=%7Bentity_id%7D"</code> (<code>%7D</code> it's <code>}</code> with urlencode)</p>
<p>A post/put/delete request to root url with the modified/new document will modifiy the document.</p>
<p><strong>NOTE</strong>
The query params and payload will be merged and used as a mongo query!
Any data manipulation operation can be done from the front-end.
</p>
<h1 id="todo-explore-security-risks">TODO explore security risks</h1>
<p>Bellow we have an example of using a schema to generate an editable table metadata and it's coresponding api.</p>
<p>We provide the information required for generating editable metadata in the <code>metadata</code> parameter.
Column names will be created from field names and other informations such as datatype, values(in case of <code>enum</code> datatype) etc will be taken from marshmallow <code>fields</code> specifications.</p>
<p>For metadata you can use either a dict or <code>metaspecs</code> function which has autocomplete.</p>
<pre><code class="language-py">
from marshmallow import Schema, fields, validate

from licenseware.common.constants import envs
from licenseware.editable_table import EditableTable, metaspecs
from licenseware.schema_namespace import MongoCrud, SchemaNamespace

from app.common.infrastructure_service import InfraService




class DeviceTableSchema(Schema):

    ''' IFMP devices editable table ''' # this will be the api doc

    class Meta:

        compound_indexes = [
            ['tenant_id', 'name'],
            ['tenant_id', 'name', 'device_type']
        ]
        simple_indexes = ['_id', 'tenant_id', 'name',
                   'is_parent_to', 'is_child_to',
                   'is_part_of_cluster_with', 'is_dr_with',
                   'device_type', 'virtualization_type',
                   'cpu_model'
                   ]


    _id = fields.Str(required=False, unique=True)
    tenant_id = fields.Str(required=True)

    name = fields.Str(required=True, unique=False, metadata=metaspecs(editable=True))

    is_parent_to = fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata={'editable': True, 'distinct_key': 'name', 'foreign_key': 'name'}
    )

    is_child_to = fields.Str(
        required=False, allow_none=True,
        metadata=metaspecs(editable=True, distinct_key='name', foreign_key='name') 
    )

    is_part_of_cluster_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata={'editable': True, 'distinct_key': 'name', 'foreign_key': 'name'}
    )
    is_dr_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata={'editable': True, 'distinct_key': 'name', 'foreign_key': 'name'}
    )

    capped = fields.Boolean(required=True, allow_none=False, metadata={'editable': True})
    total_number_of_processors = fields.Integer(required=False, allow_none=True, metadata={'editable': True})

    manufacturer = fields.Str(required=False, allow_none=True, metadata={'editable': True})
    model = fields.Str(required=False, allow_none=True, metadata={'editable': True})
    updated_at = fields.Str(required=False)
    raw_data = fields.Str(required=False, allow_none=True)

    source = fields.Str(required=False, allow_none=True, metadata={'editable': True})
    source_system_id = fields.Str(required=False, allow_none=True, metadata={'editable': True})





# here we are inheriting from `MongoCrud` class which has default crud methods
# we are overwriting the `put_data` method
class DeviceOp(MongoCrud):

    def __init__(self, schema: Schema, collection: str):
        self.schema = schema
        self.collection = collection
        super().__init__(schema, collection)


    def put_data(self, flask_request):

        query = self.get_query(flask_request)

        return InfraService(
            schema=self.schema, 
            collection=self.collection
        ).replace_one(json_data=query)


# Here we are creating a restx namespace using the schema
DeviceNs = SchemaNamespace(
    schema=DeviceTableSchema,
    collection=envs.MONGO_COLLECTION_DATA_NAME, #default can be skipped
    methods=['GET', 'PUT', 'DELETE'], #default is ['GET', 'PUT', 'POST', 'DELETE'] 
    mongo_crud_class = DeviceOp # here we provide the modified crud operations class
).initialize()


# In the case of a crud operation overwrite we need to provide to `EditableTable` the restx namespace created up 
devices_table = EditableTable(
    title=&quot;All Devices&quot;,
    schema=DeviceTableSchema,
    namespace=DeviceNs # needed in case of an overwrite
)


# If no overwrites are necessary providing just the schema will be suficient 
devices_table = EditableTable(
    title=&quot;All Devices&quot;,
    schema=DeviceTableSchema
)


</code></pre>
<p>Later, in the base <code>__init__.py</code> file import the <code><a title="licenseware.editable_table.editable_table.EditableTable" href="#licenseware.editable_table.editable_table.EditableTable">EditableTable</a></code> instance and register it to the main <code>App</code>.</p>
<pre><code class="language-py">from licenseware.common.constants import flags
from licenseware.app_builder import AppBuilder


from app.controllers.device_editable_controller import devices_table



App = AppBuilder(
    name = 'Infrastructure Mapper',
    description = 'IFMP (Infrastructure Mapper) is the ideal tool to help you get a complete picture of your entire infrastructure topology with comprehensive CPU, virtualization, and relationship details. You can combine IFMP data with data from other apps like ODBM (Oracle Database Manager) to generate consolidated reports showing your actual license utilization across your infrastructure.',
    flags = [flags.BETA]
)


App.register_editable_table(devices_table)

</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

EditableTable provided in this package is used to generate table metadata from a marshmallow Schema


From the schema provided `EditableTable(schema).specs` will return a list of editable tables metadata similar to this:

```js
[
  {
    &#34;component_id&#34;: &#34;ifmp_devicetables&#34;,
    &#34;url&#34;: &#34;http://localhost:5000/ifmp/devicetable&#34;,
    &#34;path&#34;: &#34;/devicetable&#34;,
    &#34;order&#34;: 1,
    &#34;style_attributes&#34;: {
      &#34;width&#34;: &#34;full&#34;
    },
    &#34;title&#34;: &#34;All devicetables&#34;,
    &#34;type&#34;: &#34;editable_table&#34;,
    &#34;columns&#34;: [
      {
        &#34;name&#34;: &#34;Id&#34;,
        &#34;prop&#34;: &#34;_id&#34;,
        &#34;editable&#34;: false,
        &#34;type&#34;: &#34;string&#34;,
        &#34;values&#34;: null,
        &#34;required&#34;: false,
        &#34;visible&#34;: false,
        &#34;entities_url&#34;: &#34;http://localhost:5000/ifmp/devicetable?_id=%7Bentity_id%7D&#34;,
        &#34;entities_path&#34;: &#34;/devicetable?_id=%7Bentity_id%7D&#34;
      },
      {
        &#34;name&#34;: &#34;Is Parent To&#34;,
        &#34;prop&#34;: &#34;is_parent_to&#34;,
        &#34;editable&#34;: true,
        &#34;type&#34;: &#34;entity&#34;,
        &#34;values&#34;: null,
        &#34;required&#34;: false,
        &#34;visible&#34;: false,
        &#34;entities_url&#34;: &#34;http://localhost:5000/ifmp/devicetable?distinct_key=name&amp;foreign_key=name&amp;_id=%7Bentity_id%7D&#34;,
        &#34;entities_path&#34;: &#34;/devicetable?distinct_key=name&amp;foreign_key=name&amp;_id=%7Bentity_id%7D&#34;
      },
      {
        &#34;name&#34;: &#34;Device Type&#34;,
        &#34;prop&#34;: &#34;device_type&#34;,
        &#34;editable&#34;: false,
        &#34;type&#34;: &#34;enum&#34;,
        &#34;values&#34;: [
          &#34;Cluster&#34;,
          &#34;Domain&#34;,
          &#34;Physical&#34;,
          &#34;Pool&#34;,
          &#34;Unknown&#34;,
          &#34;Virtual&#34;
        ],
        &#34;required&#34;: true,
        &#34;visible&#34;: false,
        &#34;entities_url&#34;: &#34;http://localhost:5000/ifmp/devicetable?_id=%7Bentity_id%7D&#34;,
        &#34;entities_path&#34;: &#34;/devicetable?_id=%7Bentity_id%7D&#34;
      },
    ]
  }
]

```

From the information provided up the front-end will know how to render each column based on: datatype(type), editable, required, visible parameters.


# TODO add pagination

By making a get request to the root url (`&#34;url&#34;: &#34;http://localhost:5000/ifmp/devicetable&#34;`) all data will be returned from mongo. 


A get request with the `_id` query parameter will return the coresponding document from mongo.
`&#34;entities_url&#34;: &#34;http://localhost:5000/ifmp/devicetable?_id=%7Bentity_id%7D&#34;` (`%7D` it&#39;s `}` with urlencode)


A post/put/delete request to root url with the modified/new document will modifiy the document.
   
**NOTE** 
The query params and payload will be merged and used as a mongo query! 
Any data manipulation operation can be done from the front-end.   


# TODO explore security risks



Bellow we have an example of using a schema to generate an editable table metadata and it&#39;s coresponding api.


We provide the information required for generating editable metadata in the `metadata` parameter.
Column names will be created from field names and other informations such as datatype, values(in case of `enum` datatype) etc will be taken from marshmallow `fields` specifications.


For metadata you can use either a dict or `metaspecs` function which has autocomplete.


```py

from marshmallow import Schema, fields, validate

from licenseware.common.constants import envs
from licenseware.editable_table import EditableTable, metaspecs
from licenseware.schema_namespace import MongoCrud, SchemaNamespace

from app.common.infrastructure_service import InfraService




class DeviceTableSchema(Schema):

    &#39;&#39;&#39; IFMP devices editable table &#39;&#39;&#39; # this will be the api doc
    
    class Meta:
    
        compound_indexes = [
            [&#39;tenant_id&#39;, &#39;name&#39;],
            [&#39;tenant_id&#39;, &#39;name&#39;, &#39;device_type&#39;]
        ]
        simple_indexes = [&#39;_id&#39;, &#39;tenant_id&#39;, &#39;name&#39;,
                   &#39;is_parent_to&#39;, &#39;is_child_to&#39;,
                   &#39;is_part_of_cluster_with&#39;, &#39;is_dr_with&#39;,
                   &#39;device_type&#39;, &#39;virtualization_type&#39;,
                   &#39;cpu_model&#39;
                   ]


    _id = fields.Str(required=False, unique=True)
    tenant_id = fields.Str(required=True)
    
    name = fields.Str(required=True, unique=False, metadata=metaspecs(editable=True))

    is_parent_to = fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata={&#39;editable&#39;: True, &#39;distinct_key&#39;: &#39;name&#39;, &#39;foreign_key&#39;: &#39;name&#39;}
    )

    is_child_to = fields.Str(
        required=False, allow_none=True,
        metadata=metaspecs(editable=True, distinct_key=&#39;name&#39;, foreign_key=&#39;name&#39;) 
    )

    is_part_of_cluster_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata={&#39;editable&#39;: True, &#39;distinct_key&#39;: &#39;name&#39;, &#39;foreign_key&#39;: &#39;name&#39;}
    )
    is_dr_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata={&#39;editable&#39;: True, &#39;distinct_key&#39;: &#39;name&#39;, &#39;foreign_key&#39;: &#39;name&#39;}
    )

    capped = fields.Boolean(required=True, allow_none=False, metadata={&#39;editable&#39;: True})
    total_number_of_processors = fields.Integer(required=False, allow_none=True, metadata={&#39;editable&#39;: True})

    manufacturer = fields.Str(required=False, allow_none=True, metadata={&#39;editable&#39;: True})
    model = fields.Str(required=False, allow_none=True, metadata={&#39;editable&#39;: True})
    updated_at = fields.Str(required=False)
    raw_data = fields.Str(required=False, allow_none=True)

    source = fields.Str(required=False, allow_none=True, metadata={&#39;editable&#39;: True})
    source_system_id = fields.Str(required=False, allow_none=True, metadata={&#39;editable&#39;: True})





# here we are inheriting from `MongoCrud` class which has default crud methods
# we are overwriting the `put_data` method
class DeviceOp(MongoCrud):
    
    def __init__(self, schema: Schema, collection: str):
        self.schema = schema
        self.collection = collection
        super().__init__(schema, collection)
    
    
    def put_data(self, flask_request):
        
        query = self.get_query(flask_request)
        
        return InfraService(
            schema=self.schema, 
            collection=self.collection
        ).replace_one(json_data=query)
        
    
# Here we are creating a restx namespace using the schema
DeviceNs = SchemaNamespace(
    schema=DeviceTableSchema,
    collection=envs.MONGO_COLLECTION_DATA_NAME, #default can be skipped
    methods=[&#39;GET&#39;, &#39;PUT&#39;, &#39;DELETE&#39;], #default is [&#39;GET&#39;, &#39;PUT&#39;, &#39;POST&#39;, &#39;DELETE&#39;] 
    mongo_crud_class = DeviceOp # here we provide the modified crud operations class
).initialize()


# In the case of a crud operation overwrite we need to provide to `EditableTable` the restx namespace created up 
devices_table = EditableTable(
    title=&#34;All Devices&#34;,
    schema=DeviceTableSchema,
    namespace=DeviceNs # needed in case of an overwrite
)
 

# If no overwrites are necessary providing just the schema will be suficient 
devices_table = EditableTable(
    title=&#34;All Devices&#34;,
    schema=DeviceTableSchema
)
 
 
```

Later, in the base `__init__.py` file import the `EditableTable` instance and register it to the main `App`.


```py
from licenseware.common.constants import flags
from licenseware.app_builder import AppBuilder


from app.controllers.device_editable_controller import devices_table



App = AppBuilder(
    name = &#39;Infrastructure Mapper&#39;,
    description = &#39;IFMP (Infrastructure Mapper) is the ideal tool to help you get a complete picture of your entire infrastructure topology with comprehensive CPU, virtualization, and relationship details. You can combine IFMP data with data from other apps like ODBM (Oracle Database Manager) to generate consolidated reports showing your actual license utilization across your infrastructure.&#39;,
    flags = [flags.BETA]
)


App.register_editable_table(devices_table)

```

&#34;&#34;&#34;





import os, re, itertools
from flask_restx.namespace import Namespace
from marshmallow import Schema
from licenseware.common.constants import envs
from urllib.parse import urlencode
from typing import List

from licenseware.utils.logger import log


class EditableTable:

    def __init__(
        self, 
        schema: Schema, 
        namespace: Namespace = None,
        component_id: str = None, 
        title: str = None,
        url: str = None, 
        table_type: str = &#34;editable_table&#34;,
        order: int = 1,
        style_attributes: dict = {&#39;width&#39;: &#39;full&#39;}
    ):
        self.schema = schema
        self.namespace = namespace
        
        if not &#34;Table&#34; in self.schema.__name__:
            raise ValueError(&#34;Schema provided to editable tables must contain in it&#39;s name &#39;Table&#39; keyword (ex: DeviceTableSchema)&#34;)
        
        self.schema_name = self.schema.__name__.replace(&#39;Schema&#39;, &#39;&#39;).lower()
        self.names = self.schema_name
        if not self.names.endswith(&#39;s&#39;):
            self.names = self.names + &#39;s&#39; #plural
    
        self.component_id = component_id or self.component_id_from_schema()
        self.title = title or self.title_from_schema()
        self.path = (url or self.url_from_schema())
        self.url = envs.BASE_URL + self.path
        self.table_type = table_type
        self.order = order
        self.style_attributes = style_attributes
        self.schema_dict = self.make_schema_dict()
        
        
    def url_from_schema(self):
        return f&#39;/{self.schema_name}&#39;

    def title_from_schema(self):
        return &#39;All &#39; + self.names

    def component_id_from_schema(self):
        return envs.APP_ID + &#34;_&#34; + self.names

    def make_schema_dict(self):

        field_dict = lambda data: {
            k:v for k, v in data.__dict__.items() 
            if k not in [&#39;default&#39;, &#39;_creation_index&#39;, &#39;missing&#39;, &#39;inner&#39;]
        }

        schema_dict = lambda declared_fields: {
            field: field_dict(data)
            for field, data in declared_fields.items()
        }

        return schema_dict(self.schema._declared_fields)

    @property
    def specs(self):
        return self.get_specifications()

    def get_specifications(self):
        return {
            &#34;component_id&#34;: self.component_id,
            &#34;url&#34;: self.url, 
            &#34;path&#34;: self.path,
            &#34;order&#34;: self.order,
            &#34;style_attributes&#34;: self.style_attributes,
            &#34;title&#34;: self.title,
            &#34;type&#34;: self.table_type,
            &#34;columns&#34;: self.columns_spec_list()
        }

    def columns_spec_list(self):

        columns_list = []
        for field_name, field_data in self.schema_dict.items():
            columns_list.append({
                &#34;name&#34;: self.col_name(field_name),
                &#34;prop&#34;: self.col_prop(field_name),
                &#34;editable&#34;: self.col_editable(field_data),
                &#34;type&#34;: self.col_type(field_data),
                &#34;values&#34;: self.col_enum_values(field_data),
                &#34;required&#34;: self.col_required(field_data),
                &#34;visible&#34;: self.col_visible(field_name, field_data),
                &#34;entities_url&#34;: self.col_entities_url(field_data),
                &#34;entities_path&#34;: self.col_entities_path(field_data),
            })

        return columns_list


    def col_entities_url(self, field_data, _get_only_path=False):
        &#34;&#34;&#34;
            _id - device(doc) id which contains foreign_keys to get the distinct_keys
            distinct_key - mongo&#39;s unique_key
            foreign_key  - field name that contains ids to distinct_key
            metadata={&#39;editable&#39;: False, &#39;distinct_key&#39;: &#39;name&#39;, &#39;foreign_key&#39;: &#39;is_parent_to&#39;}
        &#34;&#34;&#34;

        metadata = self.field_metadata(field_data)

        if &#39;distinct_key&#39; and &#39;foreign_key&#39; in metadata:
            if metadata[&#39;distinct_key&#39;] != None and metadata[&#39;foreign_key&#39;] != None: 
                params = urlencode({
                    &#39;distinct_key&#39;: metadata[&#39;distinct_key&#39;], 
                    &#39;foreign_key&#39; : metadata[&#39;foreign_key&#39;],
                    &#39;_id&#39;: &#39;{entity_id}&#39;
                })
                
                return f&#34;{self.path}?{params}&#34; if _get_only_path else f&#34;{self.url}?{params}&#34;

        # Create query params with just _id
        params = urlencode({&#39;_id&#39;: &#39;{entity_id}&#39;})
        
        return f&#34;{self.path}?{params}&#34; if _get_only_path else f&#34;{self.url}?{params}&#34;
    
    
    def col_entities_path(self, field_data):
        return self.col_entities_url(field_data, _get_only_path=True)
        

    def col_required(self, field_data):
        return field_data[&#39;required&#39;]

    def col_visible(self, field_name, field_data):
        metadata = self.field_metadata(field_data)
        if &#39;visible&#39; in metadata: return metadata[&#39;visible&#39;]
        if field_name.startswith(&#39;_&#39;): return False
        if field_name in [&#39;tenant_id&#39;, &#39;_id&#39;]: return False
        return False

    def col_enum_values(self, field_data):
        try:
            choices_list = []
            for data in field_data[&#39;validate&#39;]:
                choices_list.append(data.__dict__[&#39;choices&#39;])

            choices_list = sorted(list(set(itertools.chain(*choices_list))))
            return choices_list
        except: 
            return None
                  
    def col_name(self, field_name):
        return &#34; &#34;.join([f.capitalize() for f in field_name.split(&#39;_&#39;) if f != &#34;&#34;])

    def col_prop(self, field_name):
        return field_name

    def col_editable(self, field_data):
        metadata = self.field_metadata(field_data)
        if &#39;editable&#39; in metadata: return metadata[&#39;editable&#39;]
        return False

    def col_type(self, field_data):
        
        metadata = self.field_metadata(field_data)

        if &#39;type&#39; in metadata: return metadata[&#39;type&#39;]
        if &#39;distinct_key&#39; in metadata: return &#39;entity&#39;

        try:
            if field_data[&#39;validate&#39;][0].__dict__[&#39;choices&#39;]:
                return &#39;enum&#39;
        except: ...

        try:
            invalid_message = field_data[&#39;error_messages&#39;][&#39;invalid&#39;]
            return re.search(r&#39;Not a valid (.*?)\.&#39;, invalid_message).group(1).lower()
        except:...
        
    
    def field_metadata(self, field_data):
        if &#39;metadata&#39; in field_data:
            return field_data[&#39;metadata&#39;]
        return &#34;&#34;


def editable_tables_from_schemas(schemas_list: List[Schema]) -&gt; List[dict]:
    editable_tables = []
    for schema in schemas_list:
        table = EditableTable(schema)
        editable_tables.append(table.specs)
    return editable_tables</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="licenseware.editable_table.editable_table.editable_tables_from_schemas"><code class="name flex">
<span>def <span class="ident">editable_tables_from_schemas</span></span>(<span>schemas_list:Â List[marshmallow.schema.Schema]) â€‘>Â List[dict]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def editable_tables_from_schemas(schemas_list: List[Schema]) -&gt; List[dict]:
    editable_tables = []
    for schema in schemas_list:
        table = EditableTable(schema)
        editable_tables.append(table.specs)
    return editable_tables</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="licenseware.editable_table.editable_table.EditableTable"><code class="flex name class">
<span>class <span class="ident">EditableTable</span></span>
<span>(</span><span>schema:Â marshmallow.schema.Schema, namespace:Â flask_restx.namespace.NamespaceÂ =Â None, component_id:Â strÂ =Â None, title:Â strÂ =Â None, url:Â strÂ =Â None, table_type:Â strÂ =Â 'editable_table', order:Â intÂ =Â 1, style_attributes:Â dictÂ =Â {'width': 'full'})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableTable:

    def __init__(
        self, 
        schema: Schema, 
        namespace: Namespace = None,
        component_id: str = None, 
        title: str = None,
        url: str = None, 
        table_type: str = &#34;editable_table&#34;,
        order: int = 1,
        style_attributes: dict = {&#39;width&#39;: &#39;full&#39;}
    ):
        self.schema = schema
        self.namespace = namespace
        
        if not &#34;Table&#34; in self.schema.__name__:
            raise ValueError(&#34;Schema provided to editable tables must contain in it&#39;s name &#39;Table&#39; keyword (ex: DeviceTableSchema)&#34;)
        
        self.schema_name = self.schema.__name__.replace(&#39;Schema&#39;, &#39;&#39;).lower()
        self.names = self.schema_name
        if not self.names.endswith(&#39;s&#39;):
            self.names = self.names + &#39;s&#39; #plural
    
        self.component_id = component_id or self.component_id_from_schema()
        self.title = title or self.title_from_schema()
        self.path = (url or self.url_from_schema())
        self.url = envs.BASE_URL + self.path
        self.table_type = table_type
        self.order = order
        self.style_attributes = style_attributes
        self.schema_dict = self.make_schema_dict()
        
        
    def url_from_schema(self):
        return f&#39;/{self.schema_name}&#39;

    def title_from_schema(self):
        return &#39;All &#39; + self.names

    def component_id_from_schema(self):
        return envs.APP_ID + &#34;_&#34; + self.names

    def make_schema_dict(self):

        field_dict = lambda data: {
            k:v for k, v in data.__dict__.items() 
            if k not in [&#39;default&#39;, &#39;_creation_index&#39;, &#39;missing&#39;, &#39;inner&#39;]
        }

        schema_dict = lambda declared_fields: {
            field: field_dict(data)
            for field, data in declared_fields.items()
        }

        return schema_dict(self.schema._declared_fields)

    @property
    def specs(self):
        return self.get_specifications()

    def get_specifications(self):
        return {
            &#34;component_id&#34;: self.component_id,
            &#34;url&#34;: self.url, 
            &#34;path&#34;: self.path,
            &#34;order&#34;: self.order,
            &#34;style_attributes&#34;: self.style_attributes,
            &#34;title&#34;: self.title,
            &#34;type&#34;: self.table_type,
            &#34;columns&#34;: self.columns_spec_list()
        }

    def columns_spec_list(self):

        columns_list = []
        for field_name, field_data in self.schema_dict.items():
            columns_list.append({
                &#34;name&#34;: self.col_name(field_name),
                &#34;prop&#34;: self.col_prop(field_name),
                &#34;editable&#34;: self.col_editable(field_data),
                &#34;type&#34;: self.col_type(field_data),
                &#34;values&#34;: self.col_enum_values(field_data),
                &#34;required&#34;: self.col_required(field_data),
                &#34;visible&#34;: self.col_visible(field_name, field_data),
                &#34;entities_url&#34;: self.col_entities_url(field_data),
                &#34;entities_path&#34;: self.col_entities_path(field_data),
            })

        return columns_list


    def col_entities_url(self, field_data, _get_only_path=False):
        &#34;&#34;&#34;
            _id - device(doc) id which contains foreign_keys to get the distinct_keys
            distinct_key - mongo&#39;s unique_key
            foreign_key  - field name that contains ids to distinct_key
            metadata={&#39;editable&#39;: False, &#39;distinct_key&#39;: &#39;name&#39;, &#39;foreign_key&#39;: &#39;is_parent_to&#39;}
        &#34;&#34;&#34;

        metadata = self.field_metadata(field_data)

        if &#39;distinct_key&#39; and &#39;foreign_key&#39; in metadata:
            if metadata[&#39;distinct_key&#39;] != None and metadata[&#39;foreign_key&#39;] != None: 
                params = urlencode({
                    &#39;distinct_key&#39;: metadata[&#39;distinct_key&#39;], 
                    &#39;foreign_key&#39; : metadata[&#39;foreign_key&#39;],
                    &#39;_id&#39;: &#39;{entity_id}&#39;
                })
                
                return f&#34;{self.path}?{params}&#34; if _get_only_path else f&#34;{self.url}?{params}&#34;

        # Create query params with just _id
        params = urlencode({&#39;_id&#39;: &#39;{entity_id}&#39;})
        
        return f&#34;{self.path}?{params}&#34; if _get_only_path else f&#34;{self.url}?{params}&#34;
    
    
    def col_entities_path(self, field_data):
        return self.col_entities_url(field_data, _get_only_path=True)
        

    def col_required(self, field_data):
        return field_data[&#39;required&#39;]

    def col_visible(self, field_name, field_data):
        metadata = self.field_metadata(field_data)
        if &#39;visible&#39; in metadata: return metadata[&#39;visible&#39;]
        if field_name.startswith(&#39;_&#39;): return False
        if field_name in [&#39;tenant_id&#39;, &#39;_id&#39;]: return False
        return False

    def col_enum_values(self, field_data):
        try:
            choices_list = []
            for data in field_data[&#39;validate&#39;]:
                choices_list.append(data.__dict__[&#39;choices&#39;])

            choices_list = sorted(list(set(itertools.chain(*choices_list))))
            return choices_list
        except: 
            return None
                  
    def col_name(self, field_name):
        return &#34; &#34;.join([f.capitalize() for f in field_name.split(&#39;_&#39;) if f != &#34;&#34;])

    def col_prop(self, field_name):
        return field_name

    def col_editable(self, field_data):
        metadata = self.field_metadata(field_data)
        if &#39;editable&#39; in metadata: return metadata[&#39;editable&#39;]
        return False

    def col_type(self, field_data):
        
        metadata = self.field_metadata(field_data)

        if &#39;type&#39; in metadata: return metadata[&#39;type&#39;]
        if &#39;distinct_key&#39; in metadata: return &#39;entity&#39;

        try:
            if field_data[&#39;validate&#39;][0].__dict__[&#39;choices&#39;]:
                return &#39;enum&#39;
        except: ...

        try:
            invalid_message = field_data[&#39;error_messages&#39;][&#39;invalid&#39;]
            return re.search(r&#39;Not a valid (.*?)\.&#39;, invalid_message).group(1).lower()
        except:...
        
    
    def field_metadata(self, field_data):
        if &#39;metadata&#39; in field_data:
            return field_data[&#39;metadata&#39;]
        return &#34;&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="licenseware.editable_table.editable_table.EditableTable.specs"><code class="name">var <span class="ident">specs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def specs(self):
    return self.get_specifications()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_editable"><code class="name flex">
<span>def <span class="ident">col_editable</span></span>(<span>self, field_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_editable(self, field_data):
    metadata = self.field_metadata(field_data)
    if &#39;editable&#39; in metadata: return metadata[&#39;editable&#39;]
    return False</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_entities_path"><code class="name flex">
<span>def <span class="ident">col_entities_path</span></span>(<span>self, field_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_entities_path(self, field_data):
    return self.col_entities_url(field_data, _get_only_path=True)</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_entities_url"><code class="name flex">
<span>def <span class="ident">col_entities_url</span></span>(<span>self, field_data)</span>
</code></dt>
<dd>
<div class="desc"><p>_id - device(doc) id which contains foreign_keys to get the distinct_keys
distinct_key - mongo's unique_key
foreign_key
- field name that contains ids to distinct_key
metadata={'editable': False, 'distinct_key': 'name', 'foreign_key': 'is_parent_to'}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_entities_url(self, field_data, _get_only_path=False):
    &#34;&#34;&#34;
        _id - device(doc) id which contains foreign_keys to get the distinct_keys
        distinct_key - mongo&#39;s unique_key
        foreign_key  - field name that contains ids to distinct_key
        metadata={&#39;editable&#39;: False, &#39;distinct_key&#39;: &#39;name&#39;, &#39;foreign_key&#39;: &#39;is_parent_to&#39;}
    &#34;&#34;&#34;

    metadata = self.field_metadata(field_data)

    if &#39;distinct_key&#39; and &#39;foreign_key&#39; in metadata:
        if metadata[&#39;distinct_key&#39;] != None and metadata[&#39;foreign_key&#39;] != None: 
            params = urlencode({
                &#39;distinct_key&#39;: metadata[&#39;distinct_key&#39;], 
                &#39;foreign_key&#39; : metadata[&#39;foreign_key&#39;],
                &#39;_id&#39;: &#39;{entity_id}&#39;
            })
            
            return f&#34;{self.path}?{params}&#34; if _get_only_path else f&#34;{self.url}?{params}&#34;

    # Create query params with just _id
    params = urlencode({&#39;_id&#39;: &#39;{entity_id}&#39;})
    
    return f&#34;{self.path}?{params}&#34; if _get_only_path else f&#34;{self.url}?{params}&#34;</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_enum_values"><code class="name flex">
<span>def <span class="ident">col_enum_values</span></span>(<span>self, field_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_enum_values(self, field_data):
    try:
        choices_list = []
        for data in field_data[&#39;validate&#39;]:
            choices_list.append(data.__dict__[&#39;choices&#39;])

        choices_list = sorted(list(set(itertools.chain(*choices_list))))
        return choices_list
    except: 
        return None</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_name"><code class="name flex">
<span>def <span class="ident">col_name</span></span>(<span>self, field_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_name(self, field_name):
    return &#34; &#34;.join([f.capitalize() for f in field_name.split(&#39;_&#39;) if f != &#34;&#34;])</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_prop"><code class="name flex">
<span>def <span class="ident">col_prop</span></span>(<span>self, field_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_prop(self, field_name):
    return field_name</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_required"><code class="name flex">
<span>def <span class="ident">col_required</span></span>(<span>self, field_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_required(self, field_data):
    return field_data[&#39;required&#39;]</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_type"><code class="name flex">
<span>def <span class="ident">col_type</span></span>(<span>self, field_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_type(self, field_data):
    
    metadata = self.field_metadata(field_data)

    if &#39;type&#39; in metadata: return metadata[&#39;type&#39;]
    if &#39;distinct_key&#39; in metadata: return &#39;entity&#39;

    try:
        if field_data[&#39;validate&#39;][0].__dict__[&#39;choices&#39;]:
            return &#39;enum&#39;
    except: ...

    try:
        invalid_message = field_data[&#39;error_messages&#39;][&#39;invalid&#39;]
        return re.search(r&#39;Not a valid (.*?)\.&#39;, invalid_message).group(1).lower()
    except:...</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.col_visible"><code class="name flex">
<span>def <span class="ident">col_visible</span></span>(<span>self, field_name, field_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_visible(self, field_name, field_data):
    metadata = self.field_metadata(field_data)
    if &#39;visible&#39; in metadata: return metadata[&#39;visible&#39;]
    if field_name.startswith(&#39;_&#39;): return False
    if field_name in [&#39;tenant_id&#39;, &#39;_id&#39;]: return False
    return False</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.columns_spec_list"><code class="name flex">
<span>def <span class="ident">columns_spec_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def columns_spec_list(self):

    columns_list = []
    for field_name, field_data in self.schema_dict.items():
        columns_list.append({
            &#34;name&#34;: self.col_name(field_name),
            &#34;prop&#34;: self.col_prop(field_name),
            &#34;editable&#34;: self.col_editable(field_data),
            &#34;type&#34;: self.col_type(field_data),
            &#34;values&#34;: self.col_enum_values(field_data),
            &#34;required&#34;: self.col_required(field_data),
            &#34;visible&#34;: self.col_visible(field_name, field_data),
            &#34;entities_url&#34;: self.col_entities_url(field_data),
            &#34;entities_path&#34;: self.col_entities_path(field_data),
        })

    return columns_list</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.component_id_from_schema"><code class="name flex">
<span>def <span class="ident">component_id_from_schema</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def component_id_from_schema(self):
    return envs.APP_ID + &#34;_&#34; + self.names</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.field_metadata"><code class="name flex">
<span>def <span class="ident">field_metadata</span></span>(<span>self, field_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field_metadata(self, field_data):
    if &#39;metadata&#39; in field_data:
        return field_data[&#39;metadata&#39;]
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.get_specifications"><code class="name flex">
<span>def <span class="ident">get_specifications</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_specifications(self):
    return {
        &#34;component_id&#34;: self.component_id,
        &#34;url&#34;: self.url, 
        &#34;path&#34;: self.path,
        &#34;order&#34;: self.order,
        &#34;style_attributes&#34;: self.style_attributes,
        &#34;title&#34;: self.title,
        &#34;type&#34;: self.table_type,
        &#34;columns&#34;: self.columns_spec_list()
    }</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.make_schema_dict"><code class="name flex">
<span>def <span class="ident">make_schema_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_schema_dict(self):

    field_dict = lambda data: {
        k:v for k, v in data.__dict__.items() 
        if k not in [&#39;default&#39;, &#39;_creation_index&#39;, &#39;missing&#39;, &#39;inner&#39;]
    }

    schema_dict = lambda declared_fields: {
        field: field_dict(data)
        for field, data in declared_fields.items()
    }

    return schema_dict(self.schema._declared_fields)</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.title_from_schema"><code class="name flex">
<span>def <span class="ident">title_from_schema</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def title_from_schema(self):
    return &#39;All &#39; + self.names</code></pre>
</details>
</dd>
<dt id="licenseware.editable_table.editable_table.EditableTable.url_from_schema"><code class="name flex">
<span>def <span class="ident">url_from_schema</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def url_from_schema(self):
    return f&#39;/{self.schema_name}&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#todo-add-pagination">TODO add pagination</a></li>
<li><a href="#todo-explore-security-risks">TODO explore security risks</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="licenseware.editable_table" href="index.html">licenseware.editable_table</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="licenseware.editable_table.editable_table.editable_tables_from_schemas" href="#licenseware.editable_table.editable_table.editable_tables_from_schemas">editable_tables_from_schemas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="licenseware.editable_table.editable_table.EditableTable" href="#licenseware.editable_table.editable_table.EditableTable">EditableTable</a></code></h4>
<ul class="">
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_editable" href="#licenseware.editable_table.editable_table.EditableTable.col_editable">col_editable</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_entities_path" href="#licenseware.editable_table.editable_table.EditableTable.col_entities_path">col_entities_path</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_entities_url" href="#licenseware.editable_table.editable_table.EditableTable.col_entities_url">col_entities_url</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_enum_values" href="#licenseware.editable_table.editable_table.EditableTable.col_enum_values">col_enum_values</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_name" href="#licenseware.editable_table.editable_table.EditableTable.col_name">col_name</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_prop" href="#licenseware.editable_table.editable_table.EditableTable.col_prop">col_prop</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_required" href="#licenseware.editable_table.editable_table.EditableTable.col_required">col_required</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_type" href="#licenseware.editable_table.editable_table.EditableTable.col_type">col_type</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.col_visible" href="#licenseware.editable_table.editable_table.EditableTable.col_visible">col_visible</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.columns_spec_list" href="#licenseware.editable_table.editable_table.EditableTable.columns_spec_list">columns_spec_list</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.component_id_from_schema" href="#licenseware.editable_table.editable_table.EditableTable.component_id_from_schema">component_id_from_schema</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.field_metadata" href="#licenseware.editable_table.editable_table.EditableTable.field_metadata">field_metadata</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.get_specifications" href="#licenseware.editable_table.editable_table.EditableTable.get_specifications">get_specifications</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.make_schema_dict" href="#licenseware.editable_table.editable_table.EditableTable.make_schema_dict">make_schema_dict</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.specs" href="#licenseware.editable_table.editable_table.EditableTable.specs">specs</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.title_from_schema" href="#licenseware.editable_table.editable_table.EditableTable.title_from_schema">title_from_schema</a></code></li>
<li><code><a title="licenseware.editable_table.editable_table.EditableTable.url_from_schema" href="#licenseware.editable_table.editable_table.EditableTable.url_from_schema">url_from_schema</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>