# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions

name: Deploy TEST Api DEV

on:
  push:
    branches:
      - master
      - main
# This GitHub Actions workflow runs on every push to the master branch of the
# repository, and deploys a full containerized application on AWS.
#
#
# The workflow builds and deploys the Docker image for one or more
# microservices, using a CloudFormation template to deploy the image to an
# Amazon ECS service.


jobs:
  # Build and deploy a Docker image to an ECS service through CloudFormation.
  #
  # This job can be copied multiple times to deploy different microservices
  # within the same application. For example, if there is another Dockerfile
  # for another microservice in a 'backend-service' folder in the repository,
  # another job named 'deploy-backend-service' can be added to this workflow
  # which builds that Dockerfile and deploys the image to a 'backend-service'
  # ECS service in a separate CloudFormation stack.
  
  deploy-test-api:
    name: Deploy test api
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2

    - name: Configure AWS credentials
      id: creds
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id:  ${{ secrets.AWS_ACCESS_KEY_ID }} 
        aws-secret-access-key:  ${{ secrets.AWS_SECRET_ACCESS_KEY }} 
        aws-region: eu-central-1

    - name: Login ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - uses: actions/checkout@v2

    # In this step, this action saves a list of existing images,
    # the cache is created without them in the post run.
    # It also restores the cache if it exists.
    - uses: satackey/action-docker-layer-caching@v0.0.11
      # Ignore the failure of a step and avoid terminating the job.
      continue-on-error: true
    # When copying this job to add another microservice, update the image tag value
    # below (for example, 'backend' instead of 'webapp'). Also update the 'docker build'
    # command to build the new microservice's Dockerfile in the repository.
    - name: Build, tag, and push test api image
      id: build-image
      env:
        ECR_REGISTRY:  ${{ steps.login-ecr.outputs.registry }} 
        ECR_REPOSITORY: github-actions-dev
        IMAGE_TAG: dev-test-api- ${{ github.sha }} 
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
    # When copying this job to add another microservice, update the name of the stack and the
    # service name below (for example, 'backend' instead of 'webapp'). Also add parameter
    # overrides below named 'LoadBalancerPath' and 'LoadBalancerPriority' (for example,
    # 'LoadBalancerPath=/backend/*,LoadBalancerPriority=2').
    - name: Deploy ECS service with CloudFormation
      id: service-stack
      uses: aws-actions/aws-cloudformation-github-deploy@v1
      with:
        name: dev-test-api
        template: cloudformation-templates/test-api.yml
        role-arn: arn:aws:iam:: ${{ steps.creds.outputs.aws-account-id }} :role/github-actions-cloudformation-stack-role-dev
        parameter-overrides: >-
          LoadBalancerPath=/test/*,
          LoadBalancerPriority=5,
          EnvFileArn=arn:aws:s3:::dev.lware.environment/test-api.env,
          ContainerPort=5000,
          EnvTag=dev,
          ServiceName=dev-test-api,
          ImageUrl= ${{ steps.build-image.outputs.image }} 
    - name: Print service URL
      env:
        URL:  ${{ steps.service-stack.outputs.ServiceURL }} 
      run: |
        echo "Service URL: $URL"