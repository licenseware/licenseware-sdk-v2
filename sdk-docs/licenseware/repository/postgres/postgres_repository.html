<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>licenseware.repository.postgres.postgres_repository API documentation</title>
<meta name="description" content="Usage: …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>licenseware.repository.postgres.postgres_repository</code></h1>
</header>
<section id="section-intro">
<p>Usage:</p>
<pre><code class="language-py">
from marshmallow import Schema, fields
from licenseware.repository.postgres import PostgresRepository

db_url = f&quot;postgresql://{ os.environ['POSTGRES_USERNAME'] }:{ os.environ['POSTGRES_PASSWORD'] }@{ os.environ['POSTGRES_HOSTNAME'] }/{ os.environ['POSTGRES_DB'] }&quot;

db = PostgresRepository(db_url)


# Define a marshmallow schema

class UsersSchema(Schema):

    class Meta:
        __tablename__ = 'users'

    name = fields.String(required=True)
    email = fields.String(required=True)
    address = fields.String(required=True)


# __tablename__ is optional, if not completed `users` will be the table name from schema.__name__

db.register_schema(UsersSchema)


# Insert some data

db.insert_one(
    schema = UsersSchema,
    name = 'Travis',
    email = 'travis@gmail.com',
    address = 'Oradea, Centru'
)


# Insert some data in bulk

db.insert_many(
    schema = UsersSchema,
    data=[
        {
            'name': 'Anakin',
            'email': 'anakin@gmail.com',
            'address': 'Calea Lactee'
        },
        {
            'name': 'Bum',
            'email': 'bum@gmail.com',
            'address': 'Calea Lactee'
        },
        {
            'name': 'Doka',
            'email': 'doka@gmail.com',
            'address': 'Calea Lactee'
        }
    ]
)


# Fetching some data 

# First item that matched
db.fetch_one(schema_name=&quot;UsersSchema&quot;, email='travis@gmail.com')
db.fetch_by_id(schema_name=&quot;UsersSchema&quot;, id=13)

# All items that matched query
db.fetch_many(schema_name=&quot;UsersSchema&quot;, address='Oradea, Centru')

# All table
db.fetch_many(schema_name=&quot;UsersSchema&quot;)



# SQLAlchemy models can be created by inheriting from declarative base (db.Base)

class UsersTable(db.Base):

    __tablename__ = &quot;users&quot;
    __table_args__ = {'extend_existing': True} 

    id = sa.Column(sa.Integer, primary_key=True, autoincrement=True)
    name = sa.Column(sa.String)
    email = sa.Column(sa.String, unique=True)
    address = sa.Column(sa.String)


# Insert with tuple of sqlalchemy model and marshmallow schema for validation

db.insert_one(
    schema = (UsersTable, UsersSchema),
    name = 'John',
    email = 'john@gmail.com',
    address = 'Iasi, Centru'
)

# Count items matched by query

count_nbr = db.count(schema_name='UsersSchema', address='Calea Lactee')


# Update some data

db.update_one(
    schema_name='UsersSchema',
    filters={'name':'Birt'},
    data={
        'email': 'birt_updated@gmail.com'
    }
)


db.update_on_id(
    schema_name='UsersSchema', 
    id=user['id'], 
    data={'email': 'birt@gmail.com'}
)



db.update_many(
    schema_name='UsersSchema',
    filters={'address': 'Calea Lactee'},
    data={
        'address': 'Mars, Calea Lactee'
    }
)


# Delete some data


db.delete_one(
    schema_name='UsersSchema',
    email='birt@gmail.com'
)


db.delete_by_id(
    schema_name='UsersSchema',
    id=user['id']
)

db.delete_many(schema_name='UsersSchema')



# Connecting to bare bones sqlalchemy 


with db.engine.connect() as conn:

    result = conn.execute(sa.insert(UsersTable),
            [
                {
                    'name': 'Etra',
                    'email': 'etra@gmail.com',
                    'address': 'Budabesta'
                },
                {
                    'name': 'Tyron',
                    'email': 'tyron@gmail.com',
                    'address': 'Budabesta'
                },
                {
                    'name': 'Pesta',
                    'email': 'pesta@gmail.com',
                    'address': 'Budabesta'
                }
            ]
        )


# or using the session object with raw sql or sqlalchemy's sql builder


sql_query = &quot;SELECT * FROM users&quot;

cursor = db.execute(sql_query)

# print(cursor.all())

users = db.deserialize(schema_name='UsersSchema', cursor_data=cursor.all())

# print(users)


# the sql query can be just a string

sql_query = &quot;DELETE FROM users *&quot;

cursor = db.execute(sql_query)


# You set commit to true on execute or you can commit later

db.session.commit()




</code></pre>
<p>All migrations will be handled automatically</p>
<h1 id="todo-integrate-column-paramters-in-marshmallow-schema">TODO integrate column paramters in marshmallow schema</h1>
<h1 id="todo-include-basemetadata-in-postgresmigrations">TODO include Base.metadata in PostgresMigrations</h1>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

Usage:

```py

from marshmallow import Schema, fields
from licenseware.repository.postgres import PostgresRepository

db_url = f&#34;postgresql://{ os.environ[&#39;POSTGRES_USERNAME&#39;] }:{ os.environ[&#39;POSTGRES_PASSWORD&#39;] }@{ os.environ[&#39;POSTGRES_HOSTNAME&#39;] }/{ os.environ[&#39;POSTGRES_DB&#39;] }&#34;

db = PostgresRepository(db_url)


# Define a marshmallow schema

class UsersSchema(Schema):
    
    class Meta:
        __tablename__ = &#39;users&#39;
    
    name = fields.String(required=True)
    email = fields.String(required=True)
    address = fields.String(required=True)


# __tablename__ is optional, if not completed `users` will be the table name from schema.__name__

db.register_schema(UsersSchema)


# Insert some data

db.insert_one(
    schema = UsersSchema,
    name = &#39;Travis&#39;,
    email = &#39;travis@gmail.com&#39;,
    address = &#39;Oradea, Centru&#39;
)


# Insert some data in bulk

db.insert_many(
    schema = UsersSchema,
    data=[
        {
            &#39;name&#39;: &#39;Anakin&#39;,
            &#39;email&#39;: &#39;anakin@gmail.com&#39;,
            &#39;address&#39;: &#39;Calea Lactee&#39;
        },
        {
            &#39;name&#39;: &#39;Bum&#39;,
            &#39;email&#39;: &#39;bum@gmail.com&#39;,
            &#39;address&#39;: &#39;Calea Lactee&#39;
        },
        {
            &#39;name&#39;: &#39;Doka&#39;,
            &#39;email&#39;: &#39;doka@gmail.com&#39;,
            &#39;address&#39;: &#39;Calea Lactee&#39;
        }
    ]
)


# Fetching some data 

# First item that matched
db.fetch_one(schema_name=&#34;UsersSchema&#34;, email=&#39;travis@gmail.com&#39;)
db.fetch_by_id(schema_name=&#34;UsersSchema&#34;, id=13)

# All items that matched query
db.fetch_many(schema_name=&#34;UsersSchema&#34;, address=&#39;Oradea, Centru&#39;)

# All table
db.fetch_many(schema_name=&#34;UsersSchema&#34;)



# SQLAlchemy models can be created by inheriting from declarative base (db.Base)

class UsersTable(db.Base):
    
    __tablename__ = &#34;users&#34;
    __table_args__ = {&#39;extend_existing&#39;: True} 
    
    id = sa.Column(sa.Integer, primary_key=True, autoincrement=True)
    name = sa.Column(sa.String)
    email = sa.Column(sa.String, unique=True)
    address = sa.Column(sa.String)


# Insert with tuple of sqlalchemy model and marshmallow schema for validation

db.insert_one(
    schema = (UsersTable, UsersSchema),
    name = &#39;John&#39;,
    email = &#39;john@gmail.com&#39;,
    address = &#39;Iasi, Centru&#39;
)

# Count items matched by query

count_nbr = db.count(schema_name=&#39;UsersSchema&#39;, address=&#39;Calea Lactee&#39;)


# Update some data

db.update_one(
    schema_name=&#39;UsersSchema&#39;,
    filters={&#39;name&#39;:&#39;Birt&#39;},
    data={
        &#39;email&#39;: &#39;birt_updated@gmail.com&#39;
    }
)


db.update_on_id(
    schema_name=&#39;UsersSchema&#39;, 
    id=user[&#39;id&#39;], 
    data={&#39;email&#39;: &#39;birt@gmail.com&#39;}
)



db.update_many(
    schema_name=&#39;UsersSchema&#39;,
    filters={&#39;address&#39;: &#39;Calea Lactee&#39;},
    data={
        &#39;address&#39;: &#39;Mars, Calea Lactee&#39;
    }
)


# Delete some data


db.delete_one(
    schema_name=&#39;UsersSchema&#39;,
    email=&#39;birt@gmail.com&#39;
)


db.delete_by_id(
    schema_name=&#39;UsersSchema&#39;,
    id=user[&#39;id&#39;]
)

db.delete_many(schema_name=&#39;UsersSchema&#39;)



# Connecting to bare bones sqlalchemy 


with db.engine.connect() as conn:
    
    result = conn.execute(sa.insert(UsersTable),
            [
                {
                    &#39;name&#39;: &#39;Etra&#39;,
                    &#39;email&#39;: &#39;etra@gmail.com&#39;,
                    &#39;address&#39;: &#39;Budabesta&#39;
                },
                {
                    &#39;name&#39;: &#39;Tyron&#39;,
                    &#39;email&#39;: &#39;tyron@gmail.com&#39;,
                    &#39;address&#39;: &#39;Budabesta&#39;
                },
                {
                    &#39;name&#39;: &#39;Pesta&#39;,
                    &#39;email&#39;: &#39;pesta@gmail.com&#39;,
                    &#39;address&#39;: &#39;Budabesta&#39;
                }
            ]
        )
    

# or using the session object with raw sql or sqlalchemy&#39;s sql builder


sql_query = &#34;SELECT * FROM users&#34;

cursor = db.execute(sql_query)

# print(cursor.all())

users = db.deserialize(schema_name=&#39;UsersSchema&#39;, cursor_data=cursor.all())

# print(users)


# the sql query can be just a string

sql_query = &#34;DELETE FROM users *&#34;

cursor = db.execute(sql_query)


# You set commit to true on execute or you can commit later

db.session.commit()




```

All migrations will be handled automatically


# TODO integrate column paramters in marshmallow schema
# TODO include Base.metadata in PostgresMigrations



&#34;&#34;&#34;

from typing import List, Union
from collections.abc import Iterable

import sqlalchemy as sa
from sqlalchemy.orm import mapper
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import scoped_session, sessionmaker
from sqlalchemy.engine.cursor import CursorResult

from marshmallow import Schema, fields
from marshmallow.exceptions import ValidationError
from licenseware.repository.interface import RepositoryInterface

from .postgres_migrations import PostgresMigrations

# Marshmallow to Sqlalchemy fields mapper
# Only strings, integers, floats and booleans are suported for now
MATOSA_MAPPER = {
    fields.String: sa.String,
    fields.Str: sa.String,
    fields.Integer: sa.Integer,
    fields.Int: sa.Integer,
    fields.Float: sa.Float,
    fields.Boolean: sa.Boolean,
    fields.Bool: sa.Boolean
}


class PostgresRepository(RepositoryInterface):

    def __init__(self, db_url: str):
        self.db_url = db_url
        self.engine = sa.create_engine(db_url)
        self.session = scoped_session(sessionmaker(bind=self.engine))
        self.Base = declarative_base(bind=self.engine)
        self.registered_tables = {}
        self.registered_schemas = {}

    def create_all(self):
        &#34;&#34;&#34; Create connection to db, create all tables and generate migration files &#34;&#34;&#34;

        self.Base.metadata.create_all()
        migrations = PostgresMigrations(self.db_url, target_metadata=self.Base.metadata)
        migrations.make_migrations()

    def register_schema(self, schema: Schema) -&gt; str:
        &#34;&#34;&#34; Register schema &#34;&#34;&#34;

        table = self._get_table_from_schema(schema)
        self.registered_tables[schema.__name__] = table
        self.registered_schemas[schema.__name__] = schema

        if not self.has_table(table.__tablename__):
            self.create_all()  # create table if doesn&#39;t exist

        return table.__tablename__

    # Fetching data

    def _deserialize_value(self, d: any, field_name: str, idx: int):

        if isinstance(d, list):
            for item in d:
                if isinstance(item, tuple):
                    return item[idx]

        if isinstance(d, Iterable):
            if len(d) == 1:
                return getattr(d[0], field_name)

        return getattr(d, field_name)

    def deserialize(self, schema_name: str, cursor_data: any):

        if cursor_data is None: return [{}]

        schema = self.registered_schemas[schema_name]

        datali = []
        for d in cursor_data:

            data_dict = {}

            # Getting the id
            data_dict[&#39;id&#39;] = self._deserialize_value(d, field_name=&#39;id&#39;, idx=0)

            for idx, field_name in enumerate(schema().declared_fields.keys()):
                data_dict[field_name] = self._deserialize_value(d, field_name, idx + 1)

            datali.append(data_dict)

        return datali

    def fetch(self, schema_name: str, id: str = None, first: bool = False, limit: int = None, skip: int = None,
              **filters) -&gt; List[dict]:
        &#34;&#34;&#34; 
        TODO limit and skip
        &#34;&#34;&#34;

        first = first or (&#39;id&#39; in filters and len(filters) == 1)

        table = self.registered_tables[schema_name]
        filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
        sql_query = sa.select(table).where(eval(filters_string)) if filters_string else sa.select(table)

        cursor = self.execute(sql_query)

        cursor_data = cursor.first() if first else cursor.all()
        deserialized_data = self.deserialize(schema_name, cursor_data)

        return deserialized_data[0] if first else deserialized_data

    def fetch_one(self, schema_name: str, **filters) -&gt; dict:
        &#34;&#34;&#34; Get first item match &#34;&#34;&#34;
        return self.fetch(schema_name, first=True, **filters)

    def fetch_by_id(self, schema_name: str, id: str) -&gt; dict:
        &#34;&#34;&#34; Get first item match by id &#34;&#34;&#34;
        return self.fetch(schema_name, first=True, id=id)

    def fetch_many(self, schema_name: str, **filters) -&gt; List[dict]:
        &#34;&#34;&#34; Get all items that matched  &#34;&#34;&#34;
        return self.fetch(schema_name, **filters)

        # Inserting new data

    def _sa_field(self, ma_field):
        try:
            return MATOSA_MAPPER[type(ma_field)]
        except:
            raise ValueError(&#34;Only strings, integers, floats and booleans are suported for the moment&#34;)

    def _get_table_name_from_schema(self, schema: Schema):

        if self.registered_tables.get(schema.__name__):
            raise Exception(f&#34;Schema &#39;{schema.__name__}&#39; already registered&#34;)

        table_name = None
        if hasattr(schema, &#39;Meta&#39;):
            if hasattr(schema.Meta, &#39;__tablename__&#39;):
                table_name = schema.Meta.__tablename__

        if not table_name:
            table_name = schema.__name__.replace(&#34;Schema&#34;, &#34;&#34;).lower()

        return table_name

    def _get_columns(self, schema: Schema):

        sa_cols = []
        for field_name, temp_field_type in schema().declared_fields.items():
            field_type = self._sa_field(temp_field_type)
            sa_cols.append(sa.Column(field_name, field_type))
        return sa_cols

    def _get_table_from_schema(self, schema: Schema):
        &#34;&#34;&#34; Convert a marshmallow schema to a sqlalchemy model &#34;&#34;&#34;

        table_name = self._get_table_name_from_schema(schema)
        columns = self._get_columns(schema)

        Table = sa.Table(
            table_name,
            self.Base.metadata,
            sa.Column(&#39;id&#39;, sa.Integer, primary_key=True, autoincrement=True),
            *columns,
            extend_existing=True,
        )

        Model = type(table_name, (object,), {&#39;__tablename__&#39;: table_name})

        mapper(Model, Table)

        return Model

    def has_table(self, table_name: str):

        has_table = (
            sa.inspect(self.engine).dialect
                .has_table(self.engine.connect(), table_name)
        )

        return has_table

    def execute(self, sql_query: str, commit: bool = False) -&gt; CursorResult:
        &#34;&#34;&#34;
            Execute SQLAlchemy on db queries like:
            sql_query = select(UsersTable).where(UsersTable.name == &#39;John&#39;)
            
            Returns a cursor from which you can get results.
            
        &#34;&#34;&#34;

        cursor: CursorResult = self.session \
            .execute(sa.text(sql_query) if isinstance(sql_query, str) else sql_query)

        if commit: self.session.commit()

        return cursor

    def insert(self, schema: Schema, data: Union[dict, List[dict]]) -&gt; CursorResult:
        &#34;&#34;&#34; Insert dict or list of dict to db &#34;&#34;&#34;

        assert isinstance(data, dict) or isinstance(data, list)
        if isinstance(data, dict): data = [data]

        if isinstance(schema, tuple):
            table = schema[0]
            schema[1](many=True).load(data)  # marshmallow validate
        elif hasattr(schema, &#39;__tablename__&#39;):
            table = schema  # it&#39;s an SQLAlchemy Model
        else:
            schema(many=True).load(data)  # marshmallow validate
            table = self.registered_tables[schema.__name__]

        sql_query = sa.insert(table).values(data).returning(sa.text(&#39;id&#39;))
        cursor = self.execute(sql_query, commit=True)

        return cursor.all()

    def insert_one(self, schema: Schema, data: dict = None, **data_kwargs) -&gt; CursorResult:
        &#34;&#34;&#34; Insert dict to db &#34;&#34;&#34;
        return self.insert(schema, data or data_kwargs)

    def insert_with_id(self, schema: Schema, id: Union[str, int], data: dict = None, **data_kwargs) -&gt; CursorResult:
        &#34;&#34;&#34; Insert dict with a specific &#39;id&#39; &#34;&#34;&#34;
        raise NotImplementedError

    def insert_many(self, schema: Schema, data: List[dict], validate_percentage: float = 1.0) -&gt; CursorResult:
        &#34;&#34;&#34;
            TODO `validate_percentage`: what percentage of the list of data provided should be validated (0.5 is 50%)
        &#34;&#34;&#34;
        return self.insert(schema, data)

    # Updating existing data

    def count(self, schema_name: str, sql_query: any = None, **filters) -&gt; int:

        table = self.registered_tables[schema_name]

        if not sql_query:
            filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
            sql_query = sa.select(table).where(eval(filters_string)) if filters_string else sa.select(table)

        cursor = self.execute(sql_query)
        counted_items = len(cursor.all())

        # TODO not working
        # counted_items = self.session.query(sa.select([sa.func.count()]).select_from(sql_query)).count()

        return counted_items

    def _validate_on_update(self, schema_name: str, data: Union[dict, List[dict]]):

        try:
            # marshmallow validate
            schema = self.registered_schemas[schema_name]

            schema(many=True).load(data) if isinstance(data, list) else schema().load(data)

        except ValidationError as Errors:

            # When updating we are only interested if the field to be updated is valid

            errors_dict = Errors.normalized_messages()

            if isinstance(data, list):
                for d in data:
                    field_found = set.intersection(set(errors_dict.keys()), set(d.keys()))
                    if field_found: raise Errors
            else:
                field_found = set.intersection(set(errors_dict.keys()), set(data.keys()))
                if field_found: raise Errors

    def update(self, schema_name: str, filters: dict, data: Union[dict, List[dict]],
               first: bool = False) -&gt; CursorResult:
        &#34;&#34;&#34; &#34;&#34;&#34;

        self._validate_on_update(schema_name, data)

        table = self.registered_tables[schema_name]

        counted_items = self.count(schema_name, **filters)
        if first is True:
            if counted_items != 1:
                raise ValueError(&#34;Can&#39;t update one item with given filters&#34;)

        filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
        sql_query = sa.update(table).where(eval(filters_string)).values(**data)

        cursor = self.execute(sql_query, commit=True)

        return cursor

    def update_one(self, schema_name: str, filters: dict, data: dict) -&gt; CursorResult:
        &#34;&#34;&#34; Update one item &#34;&#34;&#34;
        return self.update(schema_name, filters=filters, data=data, first=True)

    def update_on_id(self, schema_name: str, id: Union[str, int], data: dict) -&gt; CursorResult:
        &#34;&#34;&#34; Update one item using the id &#34;&#34;&#34;
        return self.update(schema_name, filters={&#39;id&#39;: id}, data=data, first=True)

    def update_many(self, schema_name: str, filters: dict, data: List[dict],
                    validate_percentage: float = 1.0) -&gt; CursorResult:
        &#34;&#34;&#34;
            Update many
            TODO `validate_percentage`: what percentage of the list of data provided should be validated (0.5 is 50% of items in list)
        &#34;&#34;&#34;
        return self.update(schema_name, filters=filters, data=data)

    # Deleting existing data

    def delete(self, schema_name: str, filters: dict, first: bool = False) -&gt; CursorResult:
        &#34;&#34;&#34; Delete items &#34;&#34;&#34;

        table = self.registered_tables[schema_name]

        counted_items = self.count(schema_name, **filters)
        if first is True:
            if counted_items != 1:
                raise ValueError(&#34;Can&#39;t delete one item with given filters&#34;)

        filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
        sql_query = sa.delete(table).where(eval(filters_string)) if filters_string else sa.delete(table)

        cursor = self.execute(sql_query, commit=True)

        return cursor

    def delete_one(self, schema_name: str, **filters) -&gt; CursorResult:
        &#34;&#34;&#34; Delete one item &#34;&#34;&#34;
        return self.delete(schema_name, filters, first=True)

    def delete_by_id(self, schema_name: str, id: str) -&gt; CursorResult:
        &#34;&#34;&#34; Delete one item using the id provided &#34;&#34;&#34;
        return self.delete(schema_name, filters={&#39;id&#39;: id}, first=True)

    def delete_many(self, schema_name: str, **filters) -&gt; CursorResult:
        &#34;&#34;&#34; Delete items that match filters &#34;&#34;&#34;
        return self.delete(schema_name, filters)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository"><code class="flex name class">
<span>class <span class="ident">PostgresRepository</span></span>
<span>(</span><span>db_url: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostgresRepository(RepositoryInterface):

    def __init__(self, db_url: str):
        self.db_url = db_url
        self.engine = sa.create_engine(db_url)
        self.session = scoped_session(sessionmaker(bind=self.engine))
        self.Base = declarative_base(bind=self.engine)
        self.registered_tables = {}
        self.registered_schemas = {}

    def create_all(self):
        &#34;&#34;&#34; Create connection to db, create all tables and generate migration files &#34;&#34;&#34;

        self.Base.metadata.create_all()
        migrations = PostgresMigrations(self.db_url, target_metadata=self.Base.metadata)
        migrations.make_migrations()

    def register_schema(self, schema: Schema) -&gt; str:
        &#34;&#34;&#34; Register schema &#34;&#34;&#34;

        table = self._get_table_from_schema(schema)
        self.registered_tables[schema.__name__] = table
        self.registered_schemas[schema.__name__] = schema

        if not self.has_table(table.__tablename__):
            self.create_all()  # create table if doesn&#39;t exist

        return table.__tablename__

    # Fetching data

    def _deserialize_value(self, d: any, field_name: str, idx: int):

        if isinstance(d, list):
            for item in d:
                if isinstance(item, tuple):
                    return item[idx]

        if isinstance(d, Iterable):
            if len(d) == 1:
                return getattr(d[0], field_name)

        return getattr(d, field_name)

    def deserialize(self, schema_name: str, cursor_data: any):

        if cursor_data is None: return [{}]

        schema = self.registered_schemas[schema_name]

        datali = []
        for d in cursor_data:

            data_dict = {}

            # Getting the id
            data_dict[&#39;id&#39;] = self._deserialize_value(d, field_name=&#39;id&#39;, idx=0)

            for idx, field_name in enumerate(schema().declared_fields.keys()):
                data_dict[field_name] = self._deserialize_value(d, field_name, idx + 1)

            datali.append(data_dict)

        return datali

    def fetch(self, schema_name: str, id: str = None, first: bool = False, limit: int = None, skip: int = None,
              **filters) -&gt; List[dict]:
        &#34;&#34;&#34; 
        TODO limit and skip
        &#34;&#34;&#34;

        first = first or (&#39;id&#39; in filters and len(filters) == 1)

        table = self.registered_tables[schema_name]
        filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
        sql_query = sa.select(table).where(eval(filters_string)) if filters_string else sa.select(table)

        cursor = self.execute(sql_query)

        cursor_data = cursor.first() if first else cursor.all()
        deserialized_data = self.deserialize(schema_name, cursor_data)

        return deserialized_data[0] if first else deserialized_data

    def fetch_one(self, schema_name: str, **filters) -&gt; dict:
        &#34;&#34;&#34; Get first item match &#34;&#34;&#34;
        return self.fetch(schema_name, first=True, **filters)

    def fetch_by_id(self, schema_name: str, id: str) -&gt; dict:
        &#34;&#34;&#34; Get first item match by id &#34;&#34;&#34;
        return self.fetch(schema_name, first=True, id=id)

    def fetch_many(self, schema_name: str, **filters) -&gt; List[dict]:
        &#34;&#34;&#34; Get all items that matched  &#34;&#34;&#34;
        return self.fetch(schema_name, **filters)

        # Inserting new data

    def _sa_field(self, ma_field):
        try:
            return MATOSA_MAPPER[type(ma_field)]
        except:
            raise ValueError(&#34;Only strings, integers, floats and booleans are suported for the moment&#34;)

    def _get_table_name_from_schema(self, schema: Schema):

        if self.registered_tables.get(schema.__name__):
            raise Exception(f&#34;Schema &#39;{schema.__name__}&#39; already registered&#34;)

        table_name = None
        if hasattr(schema, &#39;Meta&#39;):
            if hasattr(schema.Meta, &#39;__tablename__&#39;):
                table_name = schema.Meta.__tablename__

        if not table_name:
            table_name = schema.__name__.replace(&#34;Schema&#34;, &#34;&#34;).lower()

        return table_name

    def _get_columns(self, schema: Schema):

        sa_cols = []
        for field_name, temp_field_type in schema().declared_fields.items():
            field_type = self._sa_field(temp_field_type)
            sa_cols.append(sa.Column(field_name, field_type))
        return sa_cols

    def _get_table_from_schema(self, schema: Schema):
        &#34;&#34;&#34; Convert a marshmallow schema to a sqlalchemy model &#34;&#34;&#34;

        table_name = self._get_table_name_from_schema(schema)
        columns = self._get_columns(schema)

        Table = sa.Table(
            table_name,
            self.Base.metadata,
            sa.Column(&#39;id&#39;, sa.Integer, primary_key=True, autoincrement=True),
            *columns,
            extend_existing=True,
        )

        Model = type(table_name, (object,), {&#39;__tablename__&#39;: table_name})

        mapper(Model, Table)

        return Model

    def has_table(self, table_name: str):

        has_table = (
            sa.inspect(self.engine).dialect
                .has_table(self.engine.connect(), table_name)
        )

        return has_table

    def execute(self, sql_query: str, commit: bool = False) -&gt; CursorResult:
        &#34;&#34;&#34;
            Execute SQLAlchemy on db queries like:
            sql_query = select(UsersTable).where(UsersTable.name == &#39;John&#39;)
            
            Returns a cursor from which you can get results.
            
        &#34;&#34;&#34;

        cursor: CursorResult = self.session \
            .execute(sa.text(sql_query) if isinstance(sql_query, str) else sql_query)

        if commit: self.session.commit()

        return cursor

    def insert(self, schema: Schema, data: Union[dict, List[dict]]) -&gt; CursorResult:
        &#34;&#34;&#34; Insert dict or list of dict to db &#34;&#34;&#34;

        assert isinstance(data, dict) or isinstance(data, list)
        if isinstance(data, dict): data = [data]

        if isinstance(schema, tuple):
            table = schema[0]
            schema[1](many=True).load(data)  # marshmallow validate
        elif hasattr(schema, &#39;__tablename__&#39;):
            table = schema  # it&#39;s an SQLAlchemy Model
        else:
            schema(many=True).load(data)  # marshmallow validate
            table = self.registered_tables[schema.__name__]

        sql_query = sa.insert(table).values(data).returning(sa.text(&#39;id&#39;))
        cursor = self.execute(sql_query, commit=True)

        return cursor.all()

    def insert_one(self, schema: Schema, data: dict = None, **data_kwargs) -&gt; CursorResult:
        &#34;&#34;&#34; Insert dict to db &#34;&#34;&#34;
        return self.insert(schema, data or data_kwargs)

    def insert_with_id(self, schema: Schema, id: Union[str, int], data: dict = None, **data_kwargs) -&gt; CursorResult:
        &#34;&#34;&#34; Insert dict with a specific &#39;id&#39; &#34;&#34;&#34;
        raise NotImplementedError

    def insert_many(self, schema: Schema, data: List[dict], validate_percentage: float = 1.0) -&gt; CursorResult:
        &#34;&#34;&#34;
            TODO `validate_percentage`: what percentage of the list of data provided should be validated (0.5 is 50%)
        &#34;&#34;&#34;
        return self.insert(schema, data)

    # Updating existing data

    def count(self, schema_name: str, sql_query: any = None, **filters) -&gt; int:

        table = self.registered_tables[schema_name]

        if not sql_query:
            filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
            sql_query = sa.select(table).where(eval(filters_string)) if filters_string else sa.select(table)

        cursor = self.execute(sql_query)
        counted_items = len(cursor.all())

        # TODO not working
        # counted_items = self.session.query(sa.select([sa.func.count()]).select_from(sql_query)).count()

        return counted_items

    def _validate_on_update(self, schema_name: str, data: Union[dict, List[dict]]):

        try:
            # marshmallow validate
            schema = self.registered_schemas[schema_name]

            schema(many=True).load(data) if isinstance(data, list) else schema().load(data)

        except ValidationError as Errors:

            # When updating we are only interested if the field to be updated is valid

            errors_dict = Errors.normalized_messages()

            if isinstance(data, list):
                for d in data:
                    field_found = set.intersection(set(errors_dict.keys()), set(d.keys()))
                    if field_found: raise Errors
            else:
                field_found = set.intersection(set(errors_dict.keys()), set(data.keys()))
                if field_found: raise Errors

    def update(self, schema_name: str, filters: dict, data: Union[dict, List[dict]],
               first: bool = False) -&gt; CursorResult:
        &#34;&#34;&#34; &#34;&#34;&#34;

        self._validate_on_update(schema_name, data)

        table = self.registered_tables[schema_name]

        counted_items = self.count(schema_name, **filters)
        if first is True:
            if counted_items != 1:
                raise ValueError(&#34;Can&#39;t update one item with given filters&#34;)

        filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
        sql_query = sa.update(table).where(eval(filters_string)).values(**data)

        cursor = self.execute(sql_query, commit=True)

        return cursor

    def update_one(self, schema_name: str, filters: dict, data: dict) -&gt; CursorResult:
        &#34;&#34;&#34; Update one item &#34;&#34;&#34;
        return self.update(schema_name, filters=filters, data=data, first=True)

    def update_on_id(self, schema_name: str, id: Union[str, int], data: dict) -&gt; CursorResult:
        &#34;&#34;&#34; Update one item using the id &#34;&#34;&#34;
        return self.update(schema_name, filters={&#39;id&#39;: id}, data=data, first=True)

    def update_many(self, schema_name: str, filters: dict, data: List[dict],
                    validate_percentage: float = 1.0) -&gt; CursorResult:
        &#34;&#34;&#34;
            Update many
            TODO `validate_percentage`: what percentage of the list of data provided should be validated (0.5 is 50% of items in list)
        &#34;&#34;&#34;
        return self.update(schema_name, filters=filters, data=data)

    # Deleting existing data

    def delete(self, schema_name: str, filters: dict, first: bool = False) -&gt; CursorResult:
        &#34;&#34;&#34; Delete items &#34;&#34;&#34;

        table = self.registered_tables[schema_name]

        counted_items = self.count(schema_name, **filters)
        if first is True:
            if counted_items != 1:
                raise ValueError(&#34;Can&#39;t delete one item with given filters&#34;)

        filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
        sql_query = sa.delete(table).where(eval(filters_string)) if filters_string else sa.delete(table)

        cursor = self.execute(sql_query, commit=True)

        return cursor

    def delete_one(self, schema_name: str, **filters) -&gt; CursorResult:
        &#34;&#34;&#34; Delete one item &#34;&#34;&#34;
        return self.delete(schema_name, filters, first=True)

    def delete_by_id(self, schema_name: str, id: str) -&gt; CursorResult:
        &#34;&#34;&#34; Delete one item using the id provided &#34;&#34;&#34;
        return self.delete(schema_name, filters={&#39;id&#39;: id}, first=True)

    def delete_many(self, schema_name: str, **filters) -&gt; CursorResult:
        &#34;&#34;&#34; Delete items that match filters &#34;&#34;&#34;
        return self.delete(schema_name, filters)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="licenseware.repository.interface.interface.RepositoryInterface" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface">RepositoryInterface</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, schema_name: str, sql_query: <built-in function any> = None, **filters) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self, schema_name: str, sql_query: any = None, **filters) -&gt; int:

    table = self.registered_tables[schema_name]

    if not sql_query:
        filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
        sql_query = sa.select(table).where(eval(filters_string)) if filters_string else sa.select(table)

    cursor = self.execute(sql_query)
    counted_items = len(cursor.all())

    # TODO not working
    # counted_items = self.session.query(sa.select([sa.func.count()]).select_from(sql_query)).count()

    return counted_items</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.create_all"><code class="name flex">
<span>def <span class="ident">create_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create connection to db, create all tables and generate migration files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_all(self):
    &#34;&#34;&#34; Create connection to db, create all tables and generate migration files &#34;&#34;&#34;

    self.Base.metadata.create_all()
    migrations = PostgresMigrations(self.db_url, target_metadata=self.Base.metadata)
    migrations.make_migrations()</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, schema_name: str, filters: dict, first: bool = False) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Delete items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, schema_name: str, filters: dict, first: bool = False) -&gt; CursorResult:
    &#34;&#34;&#34; Delete items &#34;&#34;&#34;

    table = self.registered_tables[schema_name]

    counted_items = self.count(schema_name, **filters)
    if first is True:
        if counted_items != 1:
            raise ValueError(&#34;Can&#39;t delete one item with given filters&#34;)

    filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
    sql_query = sa.delete(table).where(eval(filters_string)) if filters_string else sa.delete(table)

    cursor = self.execute(sql_query, commit=True)

    return cursor</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_by_id"><code class="name flex">
<span>def <span class="ident">delete_by_id</span></span>(<span>self, schema_name: str, id: str) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Delete one item using the id provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_by_id(self, schema_name: str, id: str) -&gt; CursorResult:
    &#34;&#34;&#34; Delete one item using the id provided &#34;&#34;&#34;
    return self.delete(schema_name, filters={&#39;id&#39;: id}, first=True)</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_many"><code class="name flex">
<span>def <span class="ident">delete_many</span></span>(<span>self, schema_name: str, **filters) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Delete items that match filters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_many(self, schema_name: str, **filters) -&gt; CursorResult:
    &#34;&#34;&#34; Delete items that match filters &#34;&#34;&#34;
    return self.delete(schema_name, filters)</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_one"><code class="name flex">
<span>def <span class="ident">delete_one</span></span>(<span>self, schema_name: str, **filters) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Delete one item</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_one(self, schema_name: str, **filters) -&gt; CursorResult:
    &#34;&#34;&#34; Delete one item &#34;&#34;&#34;
    return self.delete(schema_name, filters, first=True)</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>self, schema_name: str, cursor_data: <built-in function any>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(self, schema_name: str, cursor_data: any):

    if cursor_data is None: return [{}]

    schema = self.registered_schemas[schema_name]

    datali = []
    for d in cursor_data:

        data_dict = {}

        # Getting the id
        data_dict[&#39;id&#39;] = self._deserialize_value(d, field_name=&#39;id&#39;, idx=0)

        for idx, field_name in enumerate(schema().declared_fields.keys()):
            data_dict[field_name] = self._deserialize_value(d, field_name, idx + 1)

        datali.append(data_dict)

    return datali</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, sql_query: str, commit: bool = False) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Execute SQLAlchemy on db queries like:
sql_query = select(UsersTable).where(UsersTable.name == 'John')</p>
<p>Returns a cursor from which you can get results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, sql_query: str, commit: bool = False) -&gt; CursorResult:
    &#34;&#34;&#34;
        Execute SQLAlchemy on db queries like:
        sql_query = select(UsersTable).where(UsersTable.name == &#39;John&#39;)
        
        Returns a cursor from which you can get results.
        
    &#34;&#34;&#34;

    cursor: CursorResult = self.session \
        .execute(sa.text(sql_query) if isinstance(sql_query, str) else sql_query)

    if commit: self.session.commit()

    return cursor</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self, schema_name: str, id: str = None, first: bool = False, limit: int = None, skip: int = None, **filters) ‑> List[dict]</span>
</code></dt>
<dd>
<div class="desc"><p>TODO limit and skip</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(self, schema_name: str, id: str = None, first: bool = False, limit: int = None, skip: int = None,
          **filters) -&gt; List[dict]:
    &#34;&#34;&#34; 
    TODO limit and skip
    &#34;&#34;&#34;

    first = first or (&#39;id&#39; in filters and len(filters) == 1)

    table = self.registered_tables[schema_name]
    filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
    sql_query = sa.select(table).where(eval(filters_string)) if filters_string else sa.select(table)

    cursor = self.execute(sql_query)

    cursor_data = cursor.first() if first else cursor.all()
    deserialized_data = self.deserialize(schema_name, cursor_data)

    return deserialized_data[0] if first else deserialized_data</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.has_table"><code class="name flex">
<span>def <span class="ident">has_table</span></span>(<span>self, table_name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_table(self, table_name: str):

    has_table = (
        sa.inspect(self.engine).dialect
            .has_table(self.engine.connect(), table_name)
    )

    return has_table</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, schema: marshmallow.schema.Schema, data: Union[dict, List[dict]]) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Insert dict or list of dict to db</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, schema: Schema, data: Union[dict, List[dict]]) -&gt; CursorResult:
    &#34;&#34;&#34; Insert dict or list of dict to db &#34;&#34;&#34;

    assert isinstance(data, dict) or isinstance(data, list)
    if isinstance(data, dict): data = [data]

    if isinstance(schema, tuple):
        table = schema[0]
        schema[1](many=True).load(data)  # marshmallow validate
    elif hasattr(schema, &#39;__tablename__&#39;):
        table = schema  # it&#39;s an SQLAlchemy Model
    else:
        schema(many=True).load(data)  # marshmallow validate
        table = self.registered_tables[schema.__name__]

    sql_query = sa.insert(table).values(data).returning(sa.text(&#39;id&#39;))
    cursor = self.execute(sql_query, commit=True)

    return cursor.all()</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.register_schema"><code class="name flex">
<span>def <span class="ident">register_schema</span></span>(<span>self, schema: marshmallow.schema.Schema) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Register schema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_schema(self, schema: Schema) -&gt; str:
    &#34;&#34;&#34; Register schema &#34;&#34;&#34;

    table = self._get_table_from_schema(schema)
    self.registered_tables[schema.__name__] = table
    self.registered_schemas[schema.__name__] = schema

    if not self.has_table(table.__tablename__):
        self.create_all()  # create table if doesn&#39;t exist

    return table.__tablename__</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, schema_name: str, filters: dict, data: Union[dict, List[dict]], first: bool = False) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, schema_name: str, filters: dict, data: Union[dict, List[dict]],
           first: bool = False) -&gt; CursorResult:
    &#34;&#34;&#34; &#34;&#34;&#34;

    self._validate_on_update(schema_name, data)

    table = self.registered_tables[schema_name]

    counted_items = self.count(schema_name, **filters)
    if first is True:
        if counted_items != 1:
            raise ValueError(&#34;Can&#39;t update one item with given filters&#34;)

    filters_string = &#34;, &#34;.join([f&#34;table.{field} == filters[&#39;{field}&#39;]&#34; for field in filters])
    sql_query = sa.update(table).where(eval(filters_string)).values(**data)

    cursor = self.execute(sql_query, commit=True)

    return cursor</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.update_many"><code class="name flex">
<span>def <span class="ident">update_many</span></span>(<span>self, schema_name: str, filters: dict, data: List[dict], validate_percentage: float = 1.0) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Update many
TODO <code>validate_percentage</code>: what percentage of the list of data provided should be validated (0.5 is 50% of items in list)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_many(self, schema_name: str, filters: dict, data: List[dict],
                validate_percentage: float = 1.0) -&gt; CursorResult:
    &#34;&#34;&#34;
        Update many
        TODO `validate_percentage`: what percentage of the list of data provided should be validated (0.5 is 50% of items in list)
    &#34;&#34;&#34;
    return self.update(schema_name, filters=filters, data=data)</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.update_on_id"><code class="name flex">
<span>def <span class="ident">update_on_id</span></span>(<span>self, schema_name: str, id: Union[str, int], data: dict) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Update one item using the id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_on_id(self, schema_name: str, id: Union[str, int], data: dict) -&gt; CursorResult:
    &#34;&#34;&#34; Update one item using the id &#34;&#34;&#34;
    return self.update(schema_name, filters={&#39;id&#39;: id}, data=data, first=True)</code></pre>
</details>
</dd>
<dt id="licenseware.repository.postgres.postgres_repository.PostgresRepository.update_one"><code class="name flex">
<span>def <span class="ident">update_one</span></span>(<span>self, schema_name: str, filters: dict, data: dict) ‑> sqlalchemy.engine.cursor.CursorResult</span>
</code></dt>
<dd>
<div class="desc"><p>Update one item</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_one(self, schema_name: str, filters: dict, data: dict) -&gt; CursorResult:
    &#34;&#34;&#34; Update one item &#34;&#34;&#34;
    return self.update(schema_name, filters=filters, data=data, first=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="licenseware.repository.interface.interface.RepositoryInterface" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface">RepositoryInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="licenseware.repository.interface.interface.RepositoryInterface.fetch_by_id" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface.fetch_by_id">fetch_by_id</a></code></li>
<li><code><a title="licenseware.repository.interface.interface.RepositoryInterface.fetch_many" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface.fetch_many">fetch_many</a></code></li>
<li><code><a title="licenseware.repository.interface.interface.RepositoryInterface.fetch_one" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface.fetch_one">fetch_one</a></code></li>
<li><code><a title="licenseware.repository.interface.interface.RepositoryInterface.insert_many" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface.insert_many">insert_many</a></code></li>
<li><code><a title="licenseware.repository.interface.interface.RepositoryInterface.insert_one" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface.insert_one">insert_one</a></code></li>
<li><code><a title="licenseware.repository.interface.interface.RepositoryInterface.insert_with_id" href="../interface/interface.html#licenseware.repository.interface.interface.RepositoryInterface.insert_with_id">insert_with_id</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#todo-integrate-column-paramters-in-marshmallow-schema">TODO integrate column paramters in marshmallow schema</a></li>
<li><a href="#todo-include-basemetadata-in-postgresmigrations">TODO include Base.metadata in PostgresMigrations</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="licenseware.repository.postgres" href="index.html">licenseware.repository.postgres</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository">PostgresRepository</a></code></h4>
<ul class="two-column">
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.count" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.count">count</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.create_all" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.create_all">create_all</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.delete">delete</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_by_id" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_by_id">delete_by_id</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_many" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_many">delete_many</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_one" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.delete_one">delete_one</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.deserialize" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.deserialize">deserialize</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.execute" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.execute">execute</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.fetch" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.fetch">fetch</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.has_table" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.has_table">has_table</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.insert" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.insert">insert</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.register_schema" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.register_schema">register_schema</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.update" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.update">update</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.update_many" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.update_many">update_many</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.update_on_id" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.update_on_id">update_on_id</a></code></li>
<li><code><a title="licenseware.repository.postgres.postgres_repository.PostgresRepository.update_one" href="#licenseware.repository.postgres.postgres_repository.PostgresRepository.update_one">update_one</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>