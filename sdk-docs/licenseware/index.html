<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>licenseware API documentation</title>
<meta name="description" content="Licenseware SDK …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>licenseware</code></h1>
</header>
<section id="section-intro">
<h1 id="licenseware-sdk">Licenseware SDK</h1>
<p>This is the licenseware <strong>Python3</strong> sdk useful for quickly create apps.
The SDK handles the repetetive actions needed for creating an app (file uploads/validation, background events, api routes and more).
It helps you focus on processsing the files needed and creating reports.
</p>
<h1 id="contents">Contents</h1>
<ol>
<li><a href="#quickstart">Quickstart</a></li>
<li><a href="#what-is-an-app">What is an <code>App</code>?</a></li>
<li><a href="#set-environment-variables">Set environment variables</a></li>
<li><a href="#app-declaration"><code>App</code> declaration</a></li>
<li><a href="#uploader-declaration"><code>Uploader</code> declaration</a></li>
<li><a href="#report-declaration"><code>Report</code> declaration</a></li>
<li><a href="#custom-namespaces">Custom namespaces</a></li>
<li><a href="#endpoints-from-simple-functions">Endpoints from simple functions</a></li>
<li><a href="#the-main-file">The <code>main</code> file</a></li>
<li><a href="#licenseware-cli">Licenseware CLI</a> </li>
<li><a href="#working-on-sdk">Working on SDK</a> </li>
</ol>
<p><a name="quickstart"></a></p>
<h1 id="quickstart">Quickstart</h1>
<p>Basic app flow:</p>
<ul>
<li>User sends list of file names;</li>
<li>App through the validator function of the uploader checks which files are relevant and returns a list of validated file names;</li>
<li>User uploads the actual files, filtered based on the list provided by the uploader (the front-end does this);</li>
<li>The uploader receives the files, runs the validation on the actual file contents (before it only had the file names), and sends the valid files to the worker_function;</li>
<li>The worker function processes the files and saves them to mongo based on the structure in the serializers;</li>
<li>Once the data is fully analyzed, the user can either view data as reports or as editable tables.</li>
</ul>
<p>Here are the steps needed for local development of an app:</p>
<ul>
<li>Install the sdk : <code>pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git</code>;</li>
<li>Clone the repo for your service;</li>
<li>CD in the cloned repo locally;</li>
<li>Create a new app : <code>licenseware new-app odb</code>;</li>
<li>Create a new uploader: <code>licenseware new-uploader lms_options</code>;</li>
<li>Update modules <code>validator.py</code> <code>worker.py</code> as per processing requirements needs for <code>lms_options</code> uploader_id. Modules created will be found here: <code>app/uploaders/lms_options</code></li>
<li>Open the first terminal start the mock-server : <code>licenseware run-dev</code>;</li>
<li>Copy <code>docker-compose.yml</code> file to <code>Documents</code> folder start the databases <code>docker-compose up -d</code>;</li>
</ul>
<p>You will have mongoexpress running at: <code>http://localhost:8081/</code></p>
<p>If ports are blocked by another process and you can't start the development servers use the commands bellow (ubuntu/debian):
- <code>sudo fuser -k 4000/tcp</code> - kill process running on port <code>4000</code> to start the mock server;
- <code>sudo fuser -k 5000/tcp</code> - kill process running on port <code>5000</code> to start the dev server;</p>
<h2 id="installation">Installation</h2>
<p>Clone the repo, and install the sdk with</p>
<pre><code class="language-bash">
make install-sdk

</code></pre>
<p>Or install it with pip:</p>
<pre><code class="language-bash">
pip3 install wheel_sdk/licenseware-2.0.0-py3-none-any.whl

</code></pre>
<p>Or download the sdk wheel from <a href="https://github.com/licenseware/licenseware-sdk-v2/raw/main/wheel_sdk/licenseware-2.0.0-py3-none-any.whl">this link</a> and install it with pip.</p>
<p>I repository is public you can install it straight from github.</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git

</code></pre>
<p>Install from a specific branch</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git@branch_name

</code></pre>
<p>Install from a specific tag</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git@tag_name

</code></pre>
<p>You can use <code>git+ssh</code> if you have ssh keys configured.
Uninstall with <code>pip3 uninstall <a title="licenseware" href="#licenseware">licenseware</a></code>.</p>
<h2 id="sdk-new-version-release">SDK new version release</h2>
<ul>
<li>In <code>setup.py</code> update the package version; </li>
<li>Create a tag with that version ex: <code>git tag -a v0.0.11</code>;</li>
<li>You can list available tags with <code>git tag -n</code>;</li>
<li>Push created tag with <code>git push --tags</code></li>
</ul>
<p>Now you use pip to install it from that specific tag:</p>
<pre><code class="language-bash">
pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git@v0.0.11

</code></pre>
<p>If you want to add more details regarding this package release you can <code>Create a new release</code></p>
<ul>
<li>Click the link <code>Releases</code>;</li>
<li>Click <code>Draft a new release</code>;</li>
<li>Click <code>Tags</code>;</li>
<li>Select latest tag version name;</li>
<li>Add title and description for the release;</li>
</ul>
<p><img alt="" src="pics/release.gif"></p>
<p>Optionally you can create a wheel for this package:</p>
<pre><code class="language-bash">
python3 setup.py bdist_wheel sdist

</code></pre>
<p>And add it to binaries on the release.</p>
<h2 id="a-minimal-app">A minimal app</h2>
<p>Bellow is a full working example of almost all features the sdk provides.</p>
<p>Start the service with <code>docker-compose up -d</code></p>
<pre><code class="language-py">
import datetime
from trend_app_protect import wrap_wsgi_app

from flask import Flask
from flask_restx import Namespace, Resource
from marshmallow import Schema, fields

from licenseware.mongodata import mongodata

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import (envs, filters, flags, icons,
                                              states)
from licenseware.endpoint_builder import EndpointBuilder
from licenseware.notifications import notify_upload_status
from licenseware.report_builder import ReportBuilder
from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import styles
from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator
from licenseware.utils.logger import log

from licenseware.schema_namespace import SchemaNamespace, MongoCrud
from licenseware.editable_table import EditableTable, metaspecs



app = Flask(__name__)


# APP

App = AppBuilder(
    name = 'Infrastructure Mapper',
    description = 'Overview of devices and networks',
    flags = [flags.BETA]
)


# UPLOADERS



# Here is the worker function 
# which will process the files in the background
def rv_tools_worker(event_data):

    # Event data will contain the following information
    # event_data = {
    #     'tenant_id': 'the tenant_id from request',
    #     'filepaths': 'absolute file paths to the files uploaded',
    #     'event_id': 'the current event_id of the uploaded files',
    #     'uploader_id': 'the uploader id in our case rv_tools'
    #     'flask_request':  'data as dict from flask request'
    # }

    log.info(&quot;Starting working&quot;)
    notify_upload_status(event_data, status=states.RUNNING)
    log.debug(event_data) # here add the processing file logic
    notify_upload_status(event_data, status=states.IDLE)
    log.info(&quot;Finished working&quot;)




# Here we are defining the validation required for each upload
# If overwriting bellow mentioned methods is not necessary you can use `UploaderValidator` directly 

class RVToolsUploaderValidator(UploaderValidator): 
    # If necessary you can overwrite bellow mentioned methods
    ...

    # def calculate_quota(self, flask_request) -&gt; Tuple[dict, int]:
    # responsible for calculating quota based on tenant_id and returning a json response, status code 
    # ...

    # def get_filenames_response(self, flask_request): 
    # responsible for validating filenames and returning a json response, status code
    # ...

    # def get_file_objects_response(self, flask_request): 
    #   responsible for validating filenames, their contents and returning a json response, status code
    # ...



rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = ['RV', 'Tools'],
    filename_endswith = ['.xls', '.xlsx'],
    ignore_filenames  = ['skip_this_file.csv'],
    required_input_type = &quot;excel&quot;,
    min_rows_number = 1,
    required_sheets = ['tabvInfo', 'tabvCPU', 'tabvHost', 'tabvCluster'],
    required_columns = [
        'VM', 'Host', 'OS', 'Sockets', 'CPUs', 'Model', 'CPU Model',
        'Cluster', '# CPU', '# Cores', 'ESX Version', 'HT Active',
        'Name', 'NumCpuThreads', 'NumCpuCores'
    ]
)

# Here we are creating the uploader 
# Notice we are providing the the validator created up to `validator_class` parameter
# `worker_function` will be called when `uploader_id` is triggered
# The `uploader_id` event is triggered when files are uploaded to `/uploads/uploader_id/files` route

rv_tools_uploader = UploaderBuilder(
    name=&quot;RVTools&quot;, 
    uploader_id = 'rv_tools',
    description=&quot;XLSX export from RVTools after scanning your Vmware infrastructure.&quot;, 
    accepted_file_types=['.xls', '.xlsx'],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker,
    quota_units = 1
)

# Here we are:
# - adding the uploader to the main app (uploaders list)
# - sending uploader information to registry-service
App.register_uploader(rv_tools_uploader)




# REPORTS


class VirtualOverview(BaseReportComponent):

    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type

        super().__init__(**vars(self))


    def get_data(self, flask_request):

        match_filters = self.get_mongo_match_filters(flask_request)

        log.info(match_filters)

        return ['mongo pipeline result']


    def set_attributes(self):

        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&quot;number_of_devices&quot;, icons.SERVERS), 
            (&quot;number_of_databases&quot;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)


        # Or raw dict (same results are achived using the method up)

        attributes = {'series': [
            {
                'value_description': 'Number of devices',
                'value_key': 'number_of_devices',
                'icon': 'ServersIcon'
            },
            {
                'value_description': 'Number of databases',
                'value_key': 'number_of_databases',
                'icon': 'DatabaseIconRounded'
            }
        ]}

        # You can also return attributes
        return attributes


    def set_style_attributes(self):

        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            'width': '1/3'
        }

        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])

        return style_attributes


    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&quot;device_name&quot;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&quot;Device Name&quot;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &quot;column&quot;: &quot;database_name&quot;,
                &quot;allowed_filters&quot;: [
                    &quot;equals&quot;, &quot;contains&quot;, &quot;in_list&quot;
                ],
                &quot;visible_name&quot;: &quot;Database Name&quot;
            }

        ]



virtual_overview = VirtualOverview(
    title=&quot;Overview&quot;,
    component_id=&quot;virtual_overview&quot;,
    component_type='summary'
)

# Register component to registry-service (to act as a first class citizen)
App.register_report_component(virtual_overview)

# Component order is determined by it's position in the list
report_components=[
    virtual_overview       
]


# Define a report wich holds one or more report components
virtualization_details_report = ReportBuilder(
    name=&quot;Virtualization Details&quot;,
    report_id=&quot;virtualization_details&quot;,
    description=&quot;This report gives you a detailed view of your virtual infrastructure. Deep dive into the infrastructure topology, identify devices with missing host details and capping rules for licensing.&quot;,
    connected_apps=['ifmp-service'],
    report_components=report_components
)


App.register_report(virtualization_details_report)






# CUSTOM RESTX NAMESPACES
# We can add also custom namespaces to main IFMP Api

custom_ns = Namespace(
    name=&quot;Custom&quot;, 
    description=&quot;This is a custom namespace with the app prefix&quot;
)

@custom_ns.route(&quot;/custom-api-route&quot;)
class CustomApiRoute(Resource):    
    @custom_ns.doc(&quot;custom&quot;)
    def get(self):
        return &quot;custom-api-route&quot;

# Add it to main app 
# it will have the same namespace prefix /ifmp/v1/ + ns-prefix/custom-api-route
App.register_namespace(custom_ns, path='/ns-prefix')

# If the namespace defined up it's used on all apps 
# add it to licenseware sdk in app_builder default routes



# EndpointBuilder

# Endpoints can be generated from functions or marshmellow schemas
# add http method as a prefix to schema or function handler (get_some_data, PostDeviceDataSchema etc)

# Here we are using a function to create an endpoint like /custom_endpoint/custom_data_from_mongo

def get_custom_data_from_mongo(flask_request):
    &quot;&quot;&quot; Custom documentation &quot;&quot;&quot;

    # Some logic here

    return &quot;Some data&quot;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)

App.register_endpoint(custom_func_endpoint)



# Here we are using a marshmellow schema to generate an endpoint

class DeviceData(Schema):

    class Meta:
        collection_name = envs.MONGO_COLLECTION_DATA_NAME
        methods = ['GET', 'PUT']

    tenant_id = fields.Str(required=False)
    updated_at = fields.Str(required=False)
    device_name = fields.Str(required=True)
    device_model = fields.Str(required=False)


custom_schema_endpoint = EndpointBuilder(DeviceData)

App.register_endpoint(custom_schema_endpoint)



# Namespace from marshmallow schema using SchemaNamespace class


# Defining our schema
class UserSchema(Schema):
    &quot;&quot;&quot; Here is some Namespace docs for user &quot;&quot;&quot;
    name = fields.Str(required=True)
    occupation = fields.Str(required=True)


# Overwritting mongo crud methods 
class UserOperations(MongoCrud):

    def __init__(self, schema: Schema, collection: str):
        self.schema = schema
        self.collection = collection
        super().__init__(schema, collection)

    def get_data(self, flask_request):

        query = self.get_query(flask_request)

        results = mongodata.fetch(match=query, collection=self.collection)

        return {&quot;status&quot;: states.SUCCESS, &quot;message&quot;: results}, 200


    def post_data(self, flask_request):

        query = UserOperations.get_query(flask_request)

        data = dict(query, **{
            &quot;updated_at&quot;: datetime.datetime.utcnow().isoformat()}
        )

        inserted_docs = mongodata.insert(
            schema=self.schema,
            collection=self.collection,
            data=data
        )

        return inserted_docs


    def put_data(self, flask_request):

        query = self.get_query(flask_request)

        updated_docs = mongodata.update(
            schema=self.schema,
            match=query,
            new_data=dict(query, **{&quot;updated_at&quot;: datetime.datetime.utcnow().isoformat()}),
            collection=self.collection,
            append=False
        )

        if updated_docs == 0:
            return {&quot;status&quot;: states.SUCCESS, &quot;message&quot;: &quot;Query didn't matched any data&quot;}, 400

        return {&quot;status&quot;: states.SUCCESS, &quot;message&quot;: &quot;&quot;}, 200


    def delete_data(self, flask_request):

        query = self.get_query(flask_request)

        deleted_docs = mongodata.delete(match=query, collection=self.collection)

        return deleted_docs



# A restx namespace is generated on instantiation
UserNs = SchemaNamespace(
    schema=UserSchema,
    collection=&quot;CustomCollection&quot;,
    mongo_crud_class=UserOperations,
    decorators=[]
)

# Adding the namespace generated from schema to our App
user_ns = UserNs.initialize()
App.register_namespace(user_ns)



# Editable tables
# In the case we need to have on the front-end an datatable which can be modified by the user the `EditableTable` class can help us create a crud workflow from a marshmellow schema
# We can provide information about columns using the `metadata` parameter available on marshmellog `fields` object

# The metadata dict can hold the following values: 

# &quot;editable&quot;:bool tell front-end if values from this column can be modified by the user 
# &quot;visible&quot;: bool tell front-end if it should render column to be visible to the user
# &quot;distinct_key&quot;:str ?
# &quot;foreign_key&quot;:str  ?


# Using the method bellow routes will be created with SchemaNamespace class 


class DeviceTableSchema(Schema):

    class Meta:
        collection = envs.MONGO_COLLECTION_DATA_NAME
        methods = ['GET', 'PUT']


    _id = fields.Str(required=False, unique=True)
    tenant_id = fields.Str(required=True)
    updated_at = fields.Str(required=False)
    raw_data = fields.Str(required=False, allow_none=True)

    name = fields.Str(required=True, 
        metadata=metaspecs(editable=True, visible=True)
    )

    is_parent_to = fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key='name', 
            foreign_key='name'
        )  
    )

    is_child_to = fields.Str(
        required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key='name', 
            foreign_key='name'
        )  
    )

    is_part_of_cluster_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key='name', 
            foreign_key='name'
        )  
    )

    is_dr_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key='name', 
            foreign_key='name'
        )  
    )

    capped = fields.Boolean(
        required=True, allow_none=False, 
        metadata=metaspecs(editable=True)
    )

    total_number_of_processors = fields.Integer(
        required=False, allow_none=True, 
        metadata=metaspecs(editable=True)
    )

    oracle_core_factor = fields.Float(
        required=False, allow_none=True, 
        metadata=metaspecs(editable=True)
    )



devices_editable_table = EditableTable(
    title=&quot;All Devices&quot;,
    schema=DeviceTableSchema
)


App.register_editable_table(devices_editable_table)



# Overwrite editable tables default crud methods from SchemaNamespace

# In the case the default crud methods provided by SchemaNamespace class do not fit our case we can overwrite the method needed.


# Same schema but with another name to avoid colisions
class ProcessorsTableSchema(DeviceTableSchema): ...


# custom handling of data
class InfraService:

    def __init__(self, schema:Schema, collection:str):
        self.schema = schema
        self.collection = collection

    def replace_one(self, json_data:dict):
        #custom handling of json_data
        return [&quot;the overwritten put_data method results&quot;]



# inherits from MongoCrud and overwrites `put_data` and `get_data` methods 
class ProcessorOp(MongoCrud):

    def __init__(self, schema: Schema, collection: str):
        self.schema = schema
        self.collection = collection
        super().__init__(schema, collection)


    def get_data(self, flask_request):
        return str(flask_request)

    def put_data(self, flask_request):

        query = self.get_query(flask_request)

        return InfraService(
            schema=ProcessorsTableSchema, 
            collection=envs.MONGO_COLLECTION_DATA_NAME
        ).replace_one(json_data=query)



# creating the restx namespace
ProcessorNs = SchemaNamespace(
    schema=ProcessorsTableSchema,
    collection=envs.MONGO_COLLECTION_DATA_NAME,
    mongo_crud_class=ProcessorOp  # feeding the custom crud class to SchemaNamespace 
).initialize()


# instantiating the editable tables
processor_table = EditableTable(
    title=&quot;All Processors&quot;,
    schema=ProcessorsTableSchema,
    namespace=ProcessorNs # here we provide our custom namespace
)

# same as up register the editable table
App.register_editable_table(processor_table)




# Call init_app in the flask function factory 
App.init_app(app)
# Register app to registry-service
App.register_app()

# Protect the app with TrendMicro Application Security
# app = wrap_wsgi_app(app)



if __name__ == &quot;__main__&quot;:       
    app.run(port=4000, debug=True)



# Userid / Tenantid
# 3d1fdc6b-04bc-44c8-ae7c-5fa5b9122f1a
# dramatiq main:App.broker -p4 --watch ./ --queues odb



</code></pre>
<p>Make commands:</p>
<ul>
<li><code>make test</code> - run all unit tests.</li>
<li><code>make dev-docs</code> - this command will start a pdoc3 http server use for viewing and updating documentation for the app created;</li>
<li><code>make docs</code> - this command will generate html docs based on docstrings provided in the app;</li>
</ul>
<p>Documentation generated can be added later to github pages.</p>
<p>See more about documentation creation here <a href="https://pdoc3.github.io/pdoc/"><code>pdoc3</code></a>.</p>
<p><a name="what-is-an-app"></a></p>
<h1 id="what-is-an-app">What is an <code>App</code>?</h1>
<p>Each Licenseware <code>App</code>/<code>Service</code> is responsible for:</p>
<ul>
<li>processing files submitted by the user;</li>
<li>creating custom reports based on processed data from files. </li>
</ul>
<p>Each <strong>APP</strong> has:</p>
<ul>
<li>one or more uploaders</li>
<li>one or more reports </li>
<li>one or more report components</li>
</ul>
<p>Each <strong>UPLOADER</strong> has:</p>
<ul>
<li>one file validator class</li>
<li>one file processing/worker function</li>
</ul>
<p>Each <strong>REPORT</strong> has:</p>
<ul>
<li>one or more report components</li>
<li>report components can be attached either to app builder instance or to report builder instance</li>
</ul>
<p>Each <strong>REPORT COMPONENT</strong> has:</p>
<ul>
<li>one get_data method;</li>
<li>one url where data can be accessed;</li>
</ul>
<p><a name="set-environment-variables"></a></p>
<h1 id="set-environment-variables">Set environment variables</h1>
<p>Fist make sure you have set the environment variables:</p>
<pre><code>#.envlocal

DEBUG=true
APP_HOST=http://backend.localhost
APP_ID={{ app_id }}
ENVIRONMENT=local
FILE_UPLOAD_PATH=/tmp/lware
LWARE_IDENTITY_USER=testing-service
LWARE_IDENTITY_PASSWORD=testing123
MONGO_CONNECTION_STRING=mongodb://lware:lware-secret@localhost:27017
MONGO_DATABASE_NAME=db
AUTH_SERVICE_URL=http://backend.localhost/auth
REGISTRY_SERVICE_URL=http://backend.localhost/registry-service
USE_BACKGROUND_WORKER=false

</code></pre>
<p><code>USE_BACKGROUND_WORKER</code> set to false or not present will skip using background server and process the uploaders data straight on request.</p>
<p><a name="app-declaration"></a></p>
<h1 id="app-declaration"><code>App</code> declaration</h1>
<p><code>AppBuilder</code> class will be used to define our <code>App</code>.
This class will handle: </p>
<ul>
<li>automatic api generation;</li>
<li>sending to registry service information about <code><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code>, <code><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code>, <code><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code> and others if needed.</li>
</ul>
<pre><code class="language-py">#app_definition.py

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import flags


ifmp_app = AppBuilder(
    name = 'Infrastructure Mapper',
    description = 'Overview of devices and networks',
    flags = [flags.BETA]
)


</code></pre>
<p>The <code>ifmp_app</code> instance is now ready to attach other uploaders, reports, report components (or others) using <em>ifmp_app.register_X</em> methods.</p>
<p><a name="uploader-declaration"></a></p>
<h1 id="uploader-declaration"><code>Uploader</code> declaration</h1>
<p>The uploader is responsible for:</p>
<ul>
<li>validating files received from user;</li>
<li>calculating quota for user and sending the appropiate response if quota exceded;</li>
<li>uploading files to disk;</li>
<li>triggering <code>worker_function</code> to process the files in the background; </li>
</ul>
<p>Each uploader needs a <code>validator_class</code> and a <code>worker_function</code>.
</p>
<h2 id="creating-the-worker_function">Creating the <code>worker_function</code></h2>
<p>Here is the worker function which will process the files in the background.</p>
<pre><code class="language-py">#worker.py

from licenseware.notification import notify_upload_status
from licenseware.utils.logger import log

def rv_tools_worker(event:dict):
    log.info(&quot;Starting working&quot;)
    log.debug(event) # here add the processing file logic
    notify_upload_status(event, status=states.IDLE)
    log.info(&quot;Finished working&quot;)

</code></pre>
<p>The <code>event</code> will be a dictionary with the following contents:</p>
<pre><code class="language-js">
{
    'tenant_id': flask_request.headers.get(&quot;Tenantid&quot;),
    'filepaths': valid_filepaths, 
    'uploader_id': uploader_id,
    'event_id': event_id,
    'flask_request':  {**flask_body, **flask_headers},
    'validation_response': 'response from validator class'
}

</code></pre>
<p>Based on given <code>event</code> the <code>worker_function</code> will process the files.</p>
<h2 id="creating-the-validator_class">Creating the <code>validator_class</code></h2>
<p>Here we are defining the validation and quota calculation required for each upload.</p>
<p>Create a new class which inherits from <code>UploaderValidator</code> and overwrite <code>calculate_quota</code> function.
Method <code>calculate_quota</code> receives a flask request as a parameter which can be used to extract files and tenant_id needed for quota calculation.</p>
<p>Finally, instantiate the validator class with the required parameters needed for validation.</p>
<pre><code class="language-py">#validator.py

from typing import Tuple
from licenseware.uploader_validator import UploaderValidator


class RVToolsUploaderValidator(UploaderValidator): 
    # Overwrite `calculate_quota`, `get_filenames_response` or `get_file_objects_response` if needed
    # Otherwise you can just instantiate the class validator from `UploaderValidator` 
    ...



rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = ['RV', 'Tools'],
    filename_endswith = ['.xls', '.xlsx'],
    ignore_filenames  = ['skip_this_file.csv'],
    required_input_type = &quot;excel&quot;,
    min_rows_number = 1,
    required_sheets = ['tabvInfo', 'tabvCPU', 'tabvHost', 'tabvCluster'],
    required_columns = [
        'VM', 'Host', 'OS', 'Sockets', 'CPUs', 'Model', 'CPU Model',
        'Cluster', '# CPU', '# Cores', 'ESX Version', 'HT Active',
        'Name', 'NumCpuThreads', 'NumCpuCores'
    ]
)


</code></pre>
<p>If parameters provided for validating filenames and contents are not enough
you can also overwrite: <code>calculate_quota</code>, <code>get_filenames_response</code> and <code>get_file_objects_response</code> methods.</p>
<ul>
<li><code>calculate_quota</code>: given a flask request object calculates quota for tenant_id based on current processing units (by default it's using len(files) got from request)</li>
<li><code>get_filenames_response</code> : given a flask request object validates filenames and returns a json response, status code</li>
<li><code>get_file_objects_response</code> : given a flask request object validates filenames and contents and returns a json response, status code</li>
</ul>
<p>Now we have <code>rv_tools_validator</code> as a <code>validator_class</code> and
<code>rv_tools_worker</code> as a <code>worker_function</code>.</p>
<pre><code class="language-py">#uploader.py

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator

from ...worker import rv_tools_worker
from ...validator import rv_tools_validator



rv_tools_uploader = UploaderBuilder(
    name=&quot;RVTools&quot;, 
    uploader_id = 'rv_tools',
    description=&quot;XLSX export from RVTools after scanning your Vmware infrastructure.&quot;, 
    accepted_file_types=['.xls', '.xlsx'],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker
)


</code></pre>
<p>Great! Now we have an uploader defined!</p>
<p>We can later import the uploader in our main file and register it to our defined <code>App</code>.
The registering process will take care of api generation for uploaders.</p>
<pre><code class="language-py">ifmp_app.register_uploader(rv_tools_uploader)
</code></pre>
<p>Of course defining an uploader can be defined in just one file too.</p>
<p><a name="report-declaration"></a></p>
<h1 id="report-declaration"><code>Report</code> declaration</h1>
<p>A <code>Report</code> is composed of one or more <code>report components</code>.
Each report component will inherit from <code>BaseReportComponent</code> class.</p>
<h2 id="creating-the-report-component">Creating the <code>Report component</code></h2>
<p>The following methods will need to be overwrited:</p>
<ul>
<li>
<p><code>get_data</code> : receives a flask request needs to return data for the declared report component;</p>
<ul>
<li>use <code>match_filters = self.get_mongo_match_filters(flask_request)</code> to get default pipeline filters (tenant_id and filters from front-end);</li>
</ul>
</li>
<li>
<p><code>set_attributes</code> : return based on <code>component_type</code> component metadata which is used by front-end to render data received from <code>get_data</code> method;</p>
</li>
<li><code>set_style_attributes</code> : return component style metadata which is used by front-end to apply different css attributes
(width, height, color etc);</li>
</ul>
<p>A <code>NotImplmentedError</code> exception will raise if methods mentioned up are not overwritted.</p>
<pre><code class="language-py">#some_report_component.py

from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import style_attributes as styles
from licenseware.common.constants import icons


class VirtualOverview(BaseReportComponent):

    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type

        super().__init__(**vars(self))


    def get_data(self, flask_request):

        match_filters = self.get_mongo_match_filters(flask_request)

        log.info(match_filters)

        return ['mongo pipeline result']


    def set_attributes(self):

        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&quot;number_of_devices&quot;, icons.SERVERS), 
            (&quot;number_of_databases&quot;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)


        # Or raw dict (same results are achived using the method up)

        attributes = {'series': [
            {
                'value_description': 'Number of devices',
                'value_key': 'number_of_devices',
                'icon': 'ServersIcon'
            },
            {
                'value_description': 'Number of databases',
                'value_key': 'number_of_databases',
                'icon': 'DatabaseIconRounded'
            }
        ]}

        # You can also return attributes
        return attributes


    def set_style_attributes(self):

        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            'width': '1/3'
        }

        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])

        return style_attributes


    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&quot;device_name&quot;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&quot;Device Name&quot;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &quot;column&quot;: &quot;database_name&quot;,
                &quot;allowed_filters&quot;: [
                    &quot;equals&quot;, &quot;contains&quot;, &quot;in_list&quot;
                ],
                &quot;visible_name&quot;: &quot;Database Name&quot;
            }

        ]




virtual_overview = VirtualOverview(
    title=&quot;Overview&quot;,
    component_id=&quot;virtual_overview&quot;,
    component_type='summary'
)


</code></pre>
<p>Now <code>virtual_overview</code> is our <code>report_component</code>.</p>
<p>We can later register the component straight to the <code>App</code> or <code>Report</code></p>
<pre><code class="language-py">ifmp_app.register_report_component(virtual_overview)
</code></pre>
<h2 id="creating-the-report">Creating the <code>Report</code></h2>
<p>The report can hold one or more report components. </p>
<pre><code class="language-py">#report.py

from licenseware.report_builder import ReportBuilder
from ...some_report_component import virtual_overview


virtualization_details_report = ReportBuilder(
    name=&quot;Virtualization Details&quot;,
    report_id=&quot;virtualization_details&quot;,
    description=&quot;This report gives you a detailed view of your virtual infrastructure.&quot;,
    connected_apps=['ifmp-service'],
    report_components=[
        virtual_overview        
    ]
)

</code></pre>
<p>We can later add the report to our main <code>App</code></p>
<pre><code class="language-py">ifmp_app.register_report(virtualization_details_report)
</code></pre>
<p>Reports api will be handled by the <code>ifmp_app</code> instance.</p>
<p><a name="custom-namespaces"></a></p>
<h1 id="custom-namespaces">Custom namespaces</h1>
<p>We are not restricted using just the apis generated from <code>AppBuilder</code> we can add new custom ones to <code>App</code>/<code>ifmp_app</code>.</p>
<pre><code class="language-py">#some_namespace.py

from flask_restx import Namespace, Resource


ns = Namespace(
    name=&quot;Custom&quot;, 
    description=&quot;This is a custom namespace with the app prefix&quot;
)

@ns.route(&quot;/custom-api-route&quot;)
class CustomApiRoute(Resource):    
    @ns.doc(id=&quot;custom&quot;)
    def get(self):
        return &quot;custom-api-route&quot;

</code></pre>
<p>We can later import the namespace created to our <code>main</code> file</p>
<pre><code class="language-py">ifmp_app.register_namespace(custom_ns, path='/ns-prefix')
</code></pre>
<p><code>ifmp_app</code> will make sure it will have the app prefix.</p>
<p>If the custom namespace created is repetead for all apps consider adding it to <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> package.</p>
<p><a name="endpoints-from-simple-functions"></a></p>
<h1 id="endpoints-from-simple-functions">Endpoints from simple functions</h1>
<p>Class <code>EndpointBuilder</code> can be used to generate endpoints from simple functions.
The function name will be used to extract the http method and the route path (<code>get_custom_data_from_mongo</code> &ndash;&gt;
<code>GET</code> http-method, <code>/get_custom_data_from_mongo</code> path-route)</p>
<pre><code class="language-py">#func.py

from licenseware.endpoint_builder import EndpointBuilder

def get_custom_data_from_mongo(flask_request):
    &quot;&quot;&quot; Custom documentation &quot;&quot;&quot;

    # Some logic here

    return &quot;Some data&quot;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)
</code></pre>
<p>The function will receive a flask request as a parameter and will be added to <code>/custom_endpoint/get_custom_data_from_mongo</code></p>
<p>Later in our <code>main</code> file: </p>
<pre><code class="language-py">ifmp_app.register_endpoint(custom_func_endpoint)
</code></pre>
<p><a name="the-main-file"></a></p>
<h1 id="the-main-file">The <code>main</code> file</h1>
<p>In the main file or in <code>create_app</code> builder function (where Flask is instantiated) we can initialize the <code>App</code> with <code>ifmp_app.init_app(app)</code> where <code>app</code> is the Flask instance. </p>
<p>When <code>init_app</code> is invoked all endpoinds defined in <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> will be created and registration information will be sent to registry-service if <code>register=True</code>. You can also initiate the registration to registry-service process with <code>ifmp_app.register_app()</code> </p>
<pre><code class="language-py">
from flask import Flask
from ...app_definition import ifmp_app
from ...uploader import rv_tools_uploader
from ...some_report_component import virtual_overview
from ...report import virtualization_details_report
from ...some_namespace import ns as custom_ns
from ...func import custom_func_endpoint


app = Flask(__name__)


# These can be placed in `app_definition`  

ifmp_app.register_uploader(rv_tools_uploader)
ifmp_app.register_report_component(virtual_overview)
ifmp_app.register_report(virtualization_details_report)
ifmp_app.register_namespace(custom_ns, path='/ns-prefix')
ifmp_app.register_endpoint(custom_func_endpoint)


# Just like any other flask extension
ifmp_app.init_app(app, register=True)    


if __name__ == &quot;__main__&quot;:    
    app.run(port=4000, debug=True)


</code></pre>
<p><a name="licenseware-cli"></a></p>
<h1 id="licenseware-cli">Licenseware CLI</h1>
<p>The licenseware sdk provides also some CLI utilities for quick development.
You can invoke the cli with by typing licenseware in the terminal followed by &ndash;help for docs.</p>
<pre><code>
$ licenseware --help
Usage: licenseware [OPTIONS] COMMAND [ARGS]...

  Useful CLI commands for automatic code generation, files and folders
  creation.

Options:
  --install-completion [bash|zsh|fish|powershell|pwsh]
                                  Install completion for the specified shell.
  --show-completion [bash|zsh|fish|powershell|pwsh]
                                  Show completion for the specified shell, to
                                  copy it or customize the installation.

  --help                          Show this message and exit.

Commands:
  build-docs            Build app html docs
  build-sdk-docs        Build licenseware sdk html docs
  create-tests          Create tests from swagger docs Command example: &gt;&gt;...
  new-app               Given app_id build a new app The package structure...
  new-report            Given report_id build a new report The package...
  new-report-component  Given component_id and component_type build a new...
  new-uploader          Given uploader_id build a new uploader The package...
  recreate-files        Recreate files that are needed but missing

</code></pre>
<p>See help for a command by specifing the command name followed by &ndash;help</p>
<pre><code>$ licenseware new-report-component --help

</code></pre>
<h2 id="create-the-app-from-cli">Create the app from CLI</h2>
<p>Create the app from the terminal.
Argument <code>new-app</code> requires an <code>app_id</code>. The id will be placed in the <code>.env</code> file.</p>
<pre><code class="language-bash">
licenseware new-app ifmp

</code></pre>
<p>The entire app structure will be generated </p>
<pre><code class="language-bash">.
├── app
│   ├── common
│   │   └── __init__.py
│   ├── controllers
│   │   └── __init__.py
│   ├── __init__.py
│   ├── report_components
│   │   └── __init__.py
│   ├── reports
│   │   └── __init__.py
│   ├── serializers
│   │   └── __init__.py
│   ├── services
│   │   └── __init__.py
│   ├── uploaders
│   │   └── __init__.py
│   └── utils
│       └── __init__.py
├── app.log
├── CHANGELOG.md
├── cloudformation-templates
│   ├── odb-api_prod.yml
│   └── odb-api.yml
├── deploy
│   └── jupyter
│       ├── docker-compose.yml
│       └── requirements.txt
├── docker-compose.yml
├── docker-entrypoint.sh
├── Dockerfile
├── Dockerfile.stack
├── main.py
├── makefile
├── Procfile
├── Procfile.stack
├── README.md
├── requirements-dev.txt
├── requirements-tests.txt
├── requirements.txt
├── setup.py
├── test_files
├── tests
│   ├── __init__.py
│   └── test_starter.py
├── tox.ini
└── version.txt

14 directories, 32 files
</code></pre>
<p>All imports will be handled by the CLI when you create a new uploader, report or report_component from the terminal.</p>
<h2 id="create-a-new-uploader-from-cli">Create a new uploader from CLI</h2>
<p>Argument <code>new-uploader</code> needs a <code>uploader_id</code></p>
<pre><code class="language-bash">
licenseware new-uploader rv_tools

</code></pre>
<pre><code>.uploaders
├── __init__.py
└── rv_tools
    ├── __init__.py
    ├── validator.py
    └── worker.py
</code></pre>
<p>Uploader id will be <code>rv_tools</code>. Each uploader has a validator and a worker.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.</p>
<h2 id="create-a-new-report-from-cli">Create a new report from CLI</h2>
<p>Argument <code>new-report</code> needs a <code>report_id</code></p>
<pre><code class="language-bash">
licenseware new-report virtualization_details

</code></pre>
<pre><code>.reports
├── __init__.py
└── virtualization_details
    ├── __init__.py
    └── virtualization_details.py
</code></pre>
<p>Report id will be <code>virtualization_details</code>.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.</p>
<h2 id="create-a-new-report-component-from-cli">Create a new report component from CLI</h2>
<p>Argument <code>new-report-component</code> needs a <code>component_id</code> and a <code>component_type</code>.</p>
<pre><code class="language-bash">
licenseware new-report-component virtual_overview summary

</code></pre>
<pre><code>.report_components
├── __init__.py
└── virtual_overview
    ├── __init__.py
    └── virtual_overview.py
</code></pre>
<p>Component id will be <code>virtual_overview</code> and it's component type will be <code>summary</code>.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.</p>
<p><a name="working-on-sdk"></a></p>
<h1 id="working-on-sdk">Working on SDK</h1>
<ul>
<li>Each new feature should be placed in a package</li>
<li>Add only features that apply to all or most apps</li>
<li>
<h1 id="todo">TODO</h1>
</li>
</ul>
<h1 id="load-testing">Load testing</h1>
<p><a href="https://github.com/americanexpress/baton">baton docs</a></p>
<pre><code class="language-bash">baton -u http://localhost/appid/yourendpoint -c 10 -r 10000
</code></pre>
<h1 id="todo_1">TODO</h1>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
# Licenseware SDK

This is the licenseware **Python3** sdk useful for quickly create apps. 
The SDK handles the repetetive actions needed for creating an app (file uploads/validation, background events, api routes and more). 
It helps you focus on processsing the files needed and creating reports.  



# Contents

1. [Quickstart](#quickstart)
2. [What is an `App`?](#what-is-an-app)
3. [Set environment variables](#set-environment-variables)
4. [`App` declaration](#app-declaration)
5. [`Uploader` declaration](#uploader-declaration)
6. [`Report` declaration](#report-declaration)
7. [Custom namespaces](#custom-namespaces)
8. [Endpoints from simple functions](#endpoints-from-simple-functions)
9. [The `main` file](#the-main-file)
10. [Licenseware CLI](#licenseware-cli) 
11. [Working on SDK](#working-on-sdk) 



&lt;a name=&#34;quickstart&#34;&gt;&lt;/a&gt;
# Quickstart 


Basic app flow:

- User sends list of file names;
- App through the validator function of the uploader checks which files are relevant and returns a list of validated file names;
- User uploads the actual files, filtered based on the list provided by the uploader (the front-end does this);
- The uploader receives the files, runs the validation on the actual file contents (before it only had the file names), and sends the valid files to the worker_function;
- The worker function processes the files and saves them to mongo based on the structure in the serializers;
- Once the data is fully analyzed, the user can either view data as reports or as editable tables.


Here are the steps needed for local development of an app:

- Install the sdk : `pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git`;
- Clone the repo for your service;
- CD in the cloned repo locally;
- Create a new app : `licenseware new-app odb`;
- Create a new uploader: `licenseware new-uploader lms_options`;
- Update modules `validator.py` `worker.py` as per processing requirements needs for `lms_options` uploader_id. Modules created will be found here: `app/uploaders/lms_options`
- Open the first terminal start the mock-server : `licenseware run-dev`;
- Copy `docker-compose.yml` file to `Documents` folder start the databases `docker-compose up -d`;

You will have mongoexpress running at: `http://localhost:8081/`

If ports are blocked by another process and you can&#39;t start the development servers use the commands bellow (ubuntu/debian):
- `sudo fuser -k 4000/tcp` - kill process running on port `4000` to start the mock server;
- `sudo fuser -k 5000/tcp` - kill process running on port `5000` to start the dev server;


## Installation 

Clone the repo, and install the sdk with

```bash

make install-sdk

```

Or install it with pip:

```bash

pip3 install wheel_sdk/licenseware-2.0.0-py3-none-any.whl

```

Or download the sdk wheel from [this link](https://github.com/licenseware/licenseware-sdk-v2/raw/main/wheel_sdk/licenseware-2.0.0-py3-none-any.whl
) and install it with pip.



I repository is public you can install it straight from github.

```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git

```

Install from a specific branch

```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git@branch_name

```

Install from a specific tag

```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git@tag_name

```

You can use `git+ssh` if you have ssh keys configured. 
Uninstall with `pip3 uninstall licenseware`.


## SDK new version release

- In `setup.py` update the package version; 
- Create a tag with that version ex: `git tag -a v0.0.11`;
- You can list available tags with `git tag -n`;
- Push created tag with `git push --tags`

Now you use pip to install it from that specific tag:

```bash

pip3 install git+https://git@github.com/licenseware/licenseware-sdk-v2.git@v0.0.11

```

If you want to add more details regarding this package release you can `Create a new release`

- Click the link `Releases`;
- Click `Draft a new release`;
- Click `Tags`;
- Select latest tag version name;
- Add title and description for the release;

![](pics/release.gif)

Optionally you can create a wheel for this package:
```bash

python3 setup.py bdist_wheel sdist

```

And add it to binaries on the release.


## A minimal app

Bellow is a full working example of almost all features the sdk provides.

Start the service with `docker-compose up -d`


```py

import datetime
from trend_app_protect import wrap_wsgi_app

from flask import Flask
from flask_restx import Namespace, Resource
from marshmallow import Schema, fields

from licenseware.mongodata import mongodata

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import (envs, filters, flags, icons,
                                              states)
from licenseware.endpoint_builder import EndpointBuilder
from licenseware.notifications import notify_upload_status
from licenseware.report_builder import ReportBuilder
from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import styles
from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator
from licenseware.utils.logger import log

from licenseware.schema_namespace import SchemaNamespace, MongoCrud
from licenseware.editable_table import EditableTable, metaspecs



app = Flask(__name__)


# APP

App = AppBuilder(
    name = &#39;Infrastructure Mapper&#39;,
    description = &#39;Overview of devices and networks&#39;,
    flags = [flags.BETA]
)


# UPLOADERS



# Here is the worker function 
# which will process the files in the background
def rv_tools_worker(event_data):
    
    # Event data will contain the following information
    # event_data = {
    #     &#39;tenant_id&#39;: &#39;the tenant_id from request&#39;,
    #     &#39;filepaths&#39;: &#39;absolute file paths to the files uploaded&#39;,
    #     &#39;event_id&#39;: &#39;the current event_id of the uploaded files&#39;,
    #     &#39;uploader_id&#39;: &#39;the uploader id in our case rv_tools&#39;
    #     &#39;flask_request&#39;:  &#39;data as dict from flask request&#39;
    # }
    
    log.info(&#34;Starting working&#34;)
    notify_upload_status(event_data, status=states.RUNNING)
    log.debug(event_data) # here add the processing file logic
    notify_upload_status(event_data, status=states.IDLE)
    log.info(&#34;Finished working&#34;)
    



# Here we are defining the validation required for each upload
# If overwriting bellow mentioned methods is not necessary you can use `UploaderValidator` directly 

class RVToolsUploaderValidator(UploaderValidator): 
    # If necessary you can overwrite bellow mentioned methods
    ...
    
    # def calculate_quota(self, flask_request) -&gt; Tuple[dict, int]:
    # responsible for calculating quota based on tenant_id and returning a json response, status code 
    # ...
    
    # def get_filenames_response(self, flask_request): 
    # responsible for validating filenames and returning a json response, status code
    # ...
    
    # def get_file_objects_response(self, flask_request): 
    #   responsible for validating filenames, their contents and returning a json response, status code
    # ...
    
    

rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = [&#39;RV&#39;, &#39;Tools&#39;],
    filename_endswith = [&#39;.xls&#39;, &#39;.xlsx&#39;],
    ignore_filenames  = [&#39;skip_this_file.csv&#39;],
    required_input_type = &#34;excel&#34;,
    min_rows_number = 1,
    required_sheets = [&#39;tabvInfo&#39;, &#39;tabvCPU&#39;, &#39;tabvHost&#39;, &#39;tabvCluster&#39;],
    required_columns = [
        &#39;VM&#39;, &#39;Host&#39;, &#39;OS&#39;, &#39;Sockets&#39;, &#39;CPUs&#39;, &#39;Model&#39;, &#39;CPU Model&#39;,
        &#39;Cluster&#39;, &#39;# CPU&#39;, &#39;# Cores&#39;, &#39;ESX Version&#39;, &#39;HT Active&#39;,
        &#39;Name&#39;, &#39;NumCpuThreads&#39;, &#39;NumCpuCores&#39;
    ]
)

# Here we are creating the uploader 
# Notice we are providing the the validator created up to `validator_class` parameter
# `worker_function` will be called when `uploader_id` is triggered
# The `uploader_id` event is triggered when files are uploaded to `/uploads/uploader_id/files` route

rv_tools_uploader = UploaderBuilder(
    name=&#34;RVTools&#34;, 
    uploader_id = &#39;rv_tools&#39;,
    description=&#34;XLSX export from RVTools after scanning your Vmware infrastructure.&#34;, 
    accepted_file_types=[&#39;.xls&#39;, &#39;.xlsx&#39;],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker,
    quota_units = 1
)

# Here we are:
# - adding the uploader to the main app (uploaders list)
# - sending uploader information to registry-service
App.register_uploader(rv_tools_uploader)




# REPORTS


class VirtualOverview(BaseReportComponent):
            
    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type
        
        super().__init__(**vars(self))
        
        
    def get_data(self, flask_request):
        
        match_filters = self.get_mongo_match_filters(flask_request)
        
        log.info(match_filters)

        return [&#39;mongo pipeline result&#39;]
    
    
    def set_attributes(self):
        
        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&#34;number_of_devices&#34;, icons.SERVERS), 
            (&#34;number_of_databases&#34;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)
        
        
        # Or raw dict (same results are achived using the method up)
        
        attributes = {&#39;series&#39;: [
            {
                &#39;value_description&#39;: &#39;Number of devices&#39;,
                &#39;value_key&#39;: &#39;number_of_devices&#39;,
                &#39;icon&#39;: &#39;ServersIcon&#39;
            },
            {
                &#39;value_description&#39;: &#39;Number of databases&#39;,
                &#39;value_key&#39;: &#39;number_of_databases&#39;,
                &#39;icon&#39;: &#39;DatabaseIconRounded&#39;
            }
        ]}
        
        # You can also return attributes
        return attributes
        
        
    def set_style_attributes(self):
        
        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            &#39;width&#39;: &#39;1/3&#39;
        }
        
        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])
        
        return style_attributes
    
    
    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&#34;device_name&#34;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&#34;Device Name&#34;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &#34;column&#34;: &#34;database_name&#34;,
                &#34;allowed_filters&#34;: [
                    &#34;equals&#34;, &#34;contains&#34;, &#34;in_list&#34;
                ],
                &#34;visible_name&#34;: &#34;Database Name&#34;
            }
        
        ]
        


virtual_overview = VirtualOverview(
    title=&#34;Overview&#34;,
    component_id=&#34;virtual_overview&#34;,
    component_type=&#39;summary&#39;
)

# Register component to registry-service (to act as a first class citizen)
App.register_report_component(virtual_overview)

# Component order is determined by it&#39;s position in the list
report_components=[
    virtual_overview       
]


# Define a report wich holds one or more report components
virtualization_details_report = ReportBuilder(
    name=&#34;Virtualization Details&#34;,
    report_id=&#34;virtualization_details&#34;,
    description=&#34;This report gives you a detailed view of your virtual infrastructure. Deep dive into the infrastructure topology, identify devices with missing host details and capping rules for licensing.&#34;,
    connected_apps=[&#39;ifmp-service&#39;],
    report_components=report_components
)


App.register_report(virtualization_details_report)






# CUSTOM RESTX NAMESPACES
# We can add also custom namespaces to main IFMP Api

custom_ns = Namespace(
    name=&#34;Custom&#34;, 
    description=&#34;This is a custom namespace with the app prefix&#34;
)

@custom_ns.route(&#34;/custom-api-route&#34;)
class CustomApiRoute(Resource):    
    @custom_ns.doc(&#34;custom&#34;)
    def get(self):
        return &#34;custom-api-route&#34;
    
# Add it to main app 
# it will have the same namespace prefix /ifmp/v1/ + ns-prefix/custom-api-route
App.register_namespace(custom_ns, path=&#39;/ns-prefix&#39;)

# If the namespace defined up it&#39;s used on all apps 
# add it to licenseware sdk in app_builder default routes



# EndpointBuilder

# Endpoints can be generated from functions or marshmellow schemas
# add http method as a prefix to schema or function handler (get_some_data, PostDeviceDataSchema etc)

# Here we are using a function to create an endpoint like /custom_endpoint/custom_data_from_mongo

def get_custom_data_from_mongo(flask_request):
    &#34;&#34;&#34; Custom documentation &#34;&#34;&#34;
    
    # Some logic here

    return &#34;Some data&#34;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)

App.register_endpoint(custom_func_endpoint)



# Here we are using a marshmellow schema to generate an endpoint

class DeviceData(Schema):
    
    class Meta:
        collection_name = envs.MONGO_COLLECTION_DATA_NAME
        methods = [&#39;GET&#39;, &#39;PUT&#39;]
    
    tenant_id = fields.Str(required=False)
    updated_at = fields.Str(required=False)
    device_name = fields.Str(required=True)
    device_model = fields.Str(required=False)
    
    
custom_schema_endpoint = EndpointBuilder(DeviceData)

App.register_endpoint(custom_schema_endpoint)



# Namespace from marshmallow schema using SchemaNamespace class


# Defining our schema
class UserSchema(Schema):
    &#34;&#34;&#34; Here is some Namespace docs for user &#34;&#34;&#34;
    name = fields.Str(required=True)
    occupation = fields.Str(required=True)


# Overwritting mongo crud methods 
class UserOperations(MongoCrud):
    
    def __init__(self, schema: Schema, collection: str):
        self.schema = schema
        self.collection = collection
        super().__init__(schema, collection)
    
    def get_data(self, flask_request):
        
        query = self.get_query(flask_request)
        
        results = mongodata.fetch(match=query, collection=self.collection)

        return {&#34;status&#34;: states.SUCCESS, &#34;message&#34;: results}, 200
    
    
    def post_data(self, flask_request):

        query = UserOperations.get_query(flask_request)

        data = dict(query, **{
            &#34;updated_at&#34;: datetime.datetime.utcnow().isoformat()}
        )

        inserted_docs = mongodata.insert(
            schema=self.schema,
            collection=self.collection,
            data=data
        )

        return inserted_docs
    
    
    def put_data(self, flask_request):
        
        query = self.get_query(flask_request)
        
        updated_docs = mongodata.update(
            schema=self.schema,
            match=query,
            new_data=dict(query, **{&#34;updated_at&#34;: datetime.datetime.utcnow().isoformat()}),
            collection=self.collection,
            append=False
        )
        
        if updated_docs == 0:
            return {&#34;status&#34;: states.SUCCESS, &#34;message&#34;: &#34;Query didn&#39;t matched any data&#34;}, 400
        
        return {&#34;status&#34;: states.SUCCESS, &#34;message&#34;: &#34;&#34;}, 200
        
    
    def delete_data(self, flask_request):

        query = self.get_query(flask_request)

        deleted_docs = mongodata.delete(match=query, collection=self.collection)

        return deleted_docs

    
    
# A restx namespace is generated on instantiation
UserNs = SchemaNamespace(
    schema=UserSchema,
    collection=&#34;CustomCollection&#34;,
    mongo_crud_class=UserOperations,
    decorators=[]
)

# Adding the namespace generated from schema to our App
user_ns = UserNs.initialize()
App.register_namespace(user_ns)



# Editable tables
# In the case we need to have on the front-end an datatable which can be modified by the user the `EditableTable` class can help us create a crud workflow from a marshmellow schema
# We can provide information about columns using the `metadata` parameter available on marshmellog `fields` object

# The metadata dict can hold the following values: 

# &#34;editable&#34;:bool tell front-end if values from this column can be modified by the user 
# &#34;visible&#34;: bool tell front-end if it should render column to be visible to the user
# &#34;distinct_key&#34;:str ?
# &#34;foreign_key&#34;:str  ?


# Using the method bellow routes will be created with SchemaNamespace class 


class DeviceTableSchema(Schema):
    
    class Meta:
        collection = envs.MONGO_COLLECTION_DATA_NAME
        methods = [&#39;GET&#39;, &#39;PUT&#39;]
    
    
    _id = fields.Str(required=False, unique=True)
    tenant_id = fields.Str(required=True)
    updated_at = fields.Str(required=False)
    raw_data = fields.Str(required=False, allow_none=True)
    
    name = fields.Str(required=True, 
        metadata=metaspecs(editable=True, visible=True)
    )
    
    is_parent_to = fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key=&#39;name&#39;, 
            foreign_key=&#39;name&#39;
        )  
    )

    is_child_to = fields.Str(
        required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key=&#39;name&#39;, 
            foreign_key=&#39;name&#39;
        )  
    )

    is_part_of_cluster_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key=&#39;name&#39;, 
            foreign_key=&#39;name&#39;
        )  
    )
    
    is_dr_with =  fields.List(
        fields.Str(), required=False, allow_none=True,
        metadata=metaspecs(
            editable=True, 
            visible=True, 
            distinct_key=&#39;name&#39;, 
            foreign_key=&#39;name&#39;
        )  
    )
    
    capped = fields.Boolean(
        required=True, allow_none=False, 
        metadata=metaspecs(editable=True)
    )
    
    total_number_of_processors = fields.Integer(
        required=False, allow_none=True, 
        metadata=metaspecs(editable=True)
    )
    
    oracle_core_factor = fields.Float(
        required=False, allow_none=True, 
        metadata=metaspecs(editable=True)
    )
    
    

devices_editable_table = EditableTable(
    title=&#34;All Devices&#34;,
    schema=DeviceTableSchema
)
 

App.register_editable_table(devices_editable_table)



# Overwrite editable tables default crud methods from SchemaNamespace

# In the case the default crud methods provided by SchemaNamespace class do not fit our case we can overwrite the method needed.


# Same schema but with another name to avoid colisions
class ProcessorsTableSchema(DeviceTableSchema): ...


# custom handling of data
class InfraService:
    
    def __init__(self, schema:Schema, collection:str):
        self.schema = schema
        self.collection = collection
        
    def replace_one(self, json_data:dict):
        #custom handling of json_data
        return [&#34;the overwritten put_data method results&#34;]
    


# inherits from MongoCrud and overwrites `put_data` and `get_data` methods 
class ProcessorOp(MongoCrud):
    
    def __init__(self, schema: Schema, collection: str):
        self.schema = schema
        self.collection = collection
        super().__init__(schema, collection)
    
    
    def get_data(self, flask_request):
        return str(flask_request)
    
    def put_data(self, flask_request):
        
        query = self.get_query(flask_request)
        
        return InfraService(
            schema=ProcessorsTableSchema, 
            collection=envs.MONGO_COLLECTION_DATA_NAME
        ).replace_one(json_data=query)
        
    
    
# creating the restx namespace
ProcessorNs = SchemaNamespace(
    schema=ProcessorsTableSchema,
    collection=envs.MONGO_COLLECTION_DATA_NAME,
    mongo_crud_class=ProcessorOp  # feeding the custom crud class to SchemaNamespace 
).initialize()


# instantiating the editable tables
processor_table = EditableTable(
    title=&#34;All Processors&#34;,
    schema=ProcessorsTableSchema,
    namespace=ProcessorNs # here we provide our custom namespace
)
 
# same as up register the editable table
App.register_editable_table(processor_table)




# Call init_app in the flask function factory 
App.init_app(app)
# Register app to registry-service
App.register_app()

# Protect the app with TrendMicro Application Security
# app = wrap_wsgi_app(app)



if __name__ == &#34;__main__&#34;:       
    app.run(port=4000, debug=True)
    
    
    
# Userid / Tenantid
# 3d1fdc6b-04bc-44c8-ae7c-5fa5b9122f1a
# dramatiq main:App.broker -p4 --watch ./ --queues odb



```


Make commands:

- `make test` - run all unit tests.
- `make dev-docs` - this command will start a pdoc3 http server use for viewing and updating documentation for the app created;
- `make docs` - this command will generate html docs based on docstrings provided in the app;


Documentation generated can be added later to github pages.

See more about documentation creation here [`pdoc3`](https://pdoc3.github.io/pdoc/).



&lt;a name=&#34;what-is-an-app&#34;&gt;&lt;/a&gt;
# What is an `App`?


Each Licenseware `App`/`Service` is responsible for:

- processing files submitted by the user;
- creating custom reports based on processed data from files. 


Each **APP** has:

- one or more uploaders
- one or more reports 
- one or more report components


Each **UPLOADER** has:

- one file validator class
- one file processing/worker function


Each **REPORT** has:

- one or more report components
- report components can be attached either to app builder instance or to report builder instance


Each **REPORT COMPONENT** has:

- one get_data method;
- one url where data can be accessed;


&lt;a name=&#34;set-environment-variables&#34;&gt;&lt;/a&gt;
# Set environment variables


Fist make sure you have set the environment variables:

```
#.envlocal

DEBUG=true
APP_HOST=http://backend.localhost
APP_ID={{ app_id }}
ENVIRONMENT=local
FILE_UPLOAD_PATH=/tmp/lware
LWARE_IDENTITY_USER=testing-service
LWARE_IDENTITY_PASSWORD=testing123
MONGO_CONNECTION_STRING=mongodb://lware:lware-secret@localhost:27017
MONGO_DATABASE_NAME=db
AUTH_SERVICE_URL=http://backend.localhost/auth
REGISTRY_SERVICE_URL=http://backend.localhost/registry-service
USE_BACKGROUND_WORKER=false

```

`USE_BACKGROUND_WORKER` set to false or not present will skip using background server and process the uploaders data straight on request.


&lt;a name=&#34;app-declaration&#34;&gt;&lt;/a&gt;
# `App` declaration


`AppBuilder` class will be used to define our `App`. 
This class will handle: 

- automatic api generation;
- sending to registry service information about `uploader_builder`, `report_builder`, `report_components` and others if needed.


```py
#app_definition.py

from licenseware.app_builder import AppBuilder
from licenseware.common.constants import flags


ifmp_app = AppBuilder(
    name = &#39;Infrastructure Mapper&#39;,
    description = &#39;Overview of devices and networks&#39;,
    flags = [flags.BETA]
)


```

The `ifmp_app` instance is now ready to attach other uploaders, reports, report components (or others) using *ifmp_app.register_X* methods.



&lt;a name=&#34;uploader-declaration&#34;&gt;&lt;/a&gt;
# `Uploader` declaration


The uploader is responsible for:

- validating files received from user;
- calculating quota for user and sending the appropiate response if quota exceded;
- uploading files to disk;
- triggering `worker_function` to process the files in the background; 

Each uploader needs a `validator_class` and a `worker_function`.  


## Creating the `worker_function`

Here is the worker function which will process the files in the background.

```py
#worker.py

from licenseware.notification import notify_upload_status
from licenseware.utils.logger import log

def rv_tools_worker(event:dict):
    log.info(&#34;Starting working&#34;)
    log.debug(event) # here add the processing file logic
    notify_upload_status(event, status=states.IDLE)
    log.info(&#34;Finished working&#34;)
    
```

The `event` will be a dictionary with the following contents:

```js

{
    &#39;tenant_id&#39;: flask_request.headers.get(&#34;Tenantid&#34;),
    &#39;filepaths&#39;: valid_filepaths, 
    &#39;uploader_id&#39;: uploader_id,
    &#39;event_id&#39;: event_id,
    &#39;flask_request&#39;:  {**flask_body, **flask_headers},
    &#39;validation_response&#39;: &#39;response from validator class&#39;
}

```

Based on given `event` the `worker_function` will process the files.


## Creating the `validator_class`

Here we are defining the validation and quota calculation required for each upload.

Create a new class which inherits from `UploaderValidator` and overwrite `calculate_quota` function.
Method `calculate_quota` receives a flask request as a parameter which can be used to extract files and tenant_id needed for quota calculation.

Finally, instantiate the validator class with the required parameters needed for validation.

```py
#validator.py

from typing import Tuple
from licenseware.uploader_validator import UploaderValidator


class RVToolsUploaderValidator(UploaderValidator): 
    # Overwrite `calculate_quota`, `get_filenames_response` or `get_file_objects_response` if needed
    # Otherwise you can just instantiate the class validator from `UploaderValidator` 
    ...
    
    
    
rv_tools_validator = RVToolsUploaderValidator(
    filename_contains = [&#39;RV&#39;, &#39;Tools&#39;],
    filename_endswith = [&#39;.xls&#39;, &#39;.xlsx&#39;],
    ignore_filenames  = [&#39;skip_this_file.csv&#39;],
    required_input_type = &#34;excel&#34;,
    min_rows_number = 1,
    required_sheets = [&#39;tabvInfo&#39;, &#39;tabvCPU&#39;, &#39;tabvHost&#39;, &#39;tabvCluster&#39;],
    required_columns = [
        &#39;VM&#39;, &#39;Host&#39;, &#39;OS&#39;, &#39;Sockets&#39;, &#39;CPUs&#39;, &#39;Model&#39;, &#39;CPU Model&#39;,
        &#39;Cluster&#39;, &#39;# CPU&#39;, &#39;# Cores&#39;, &#39;ESX Version&#39;, &#39;HT Active&#39;,
        &#39;Name&#39;, &#39;NumCpuThreads&#39;, &#39;NumCpuCores&#39;
    ]
)


```

If parameters provided for validating filenames and contents are not enough 
you can also overwrite: `calculate_quota`, `get_filenames_response` and `get_file_objects_response` methods.

- `calculate_quota`: given a flask request object calculates quota for tenant_id based on current processing units (by default it&#39;s using len(files) got from request)
- `get_filenames_response` : given a flask request object validates filenames and returns a json response, status code
- `get_file_objects_response` : given a flask request object validates filenames and contents and returns a json response, status code


Now we have `rv_tools_validator` as a `validator_class` and  `rv_tools_worker` as a `worker_function`.


```py
#uploader.py

from licenseware.uploader_builder import UploaderBuilder
from licenseware.uploader_validator import UploaderValidator

from ...worker import rv_tools_worker
from ...validator import rv_tools_validator



rv_tools_uploader = UploaderBuilder(
    name=&#34;RVTools&#34;, 
    uploader_id = &#39;rv_tools&#39;,
    description=&#34;XLSX export from RVTools after scanning your Vmware infrastructure.&#34;, 
    accepted_file_types=[&#39;.xls&#39;, &#39;.xlsx&#39;],
    validator_class=rv_tools_validator,
    worker_function=rv_tools_worker
)


```

Great! Now we have an uploader defined!

We can later import the uploader in our main file and register it to our defined `App`.
The registering process will take care of api generation for uploaders.

```py
ifmp_app.register_uploader(rv_tools_uploader)
```

Of course defining an uploader can be defined in just one file too.













&lt;a name=&#34;report-declaration&#34;&gt;&lt;/a&gt;
# `Report` declaration


A `Report` is composed of one or more `report components`. 
Each report component will inherit from `BaseReportComponent` class.


## Creating the `Report component`

The following methods will need to be overwrited:

- `get_data` : receives a flask request needs to return data for the declared report component;
    - use `match_filters = self.get_mongo_match_filters(flask_request)` to get default pipeline filters (tenant_id and filters from front-end);

- `set_attributes` : return based on `component_type` component metadata which is used by front-end to render data received from `get_data` method;
- `set_style_attributes` : return component style metadata which is used by front-end to apply different css attributes  (width, height, color etc);

A `NotImplmentedError` exception will raise if methods mentioned up are not overwritted.


```py
#some_report_component.py

from licenseware.report_components import BaseReportComponent
from licenseware.report_components.style_attributes import style_attributes as styles
from licenseware.common.constants import icons


class VirtualOverview(BaseReportComponent):
            
    def __init__(
        self, 
        title: str, 
        component_id: str, 
        component_type: str
    ):
        self.title = title
        self.component_id = component_id
        self.component_type = component_type
        
        super().__init__(**vars(self))
        
        
    def get_data(self, flask_request):
        
        match_filters = self.get_mongo_match_filters(flask_request)
        
        log.info(match_filters)

        return [&#39;mongo pipeline result&#39;]
    
    
    def set_attributes(self):
        
        # Short hand based on value_key
        # See based on component type funcs from: licenseware.report_components.attributes
        value_key_and_icon = [
            (&#34;number_of_devices&#34;, icons.SERVERS), 
            (&#34;number_of_databases&#34;, icons.DATABASE_ROUNDED)
        ]

        # Set values straight to self.attributes
        self.attributes = self.build_attributes(value_key_and_icon)
        
        
        # Or raw dict (same results are achived using the method up)
        
        attributes = {&#39;series&#39;: [
            {
                &#39;value_description&#39;: &#39;Number of devices&#39;,
                &#39;value_key&#39;: &#39;number_of_devices&#39;,
                &#39;icon&#39;: &#39;ServersIcon&#39;
            },
            {
                &#39;value_description&#39;: &#39;Number of databases&#39;,
                &#39;value_key&#39;: &#39;number_of_databases&#39;,
                &#39;icon&#39;: &#39;DatabaseIconRounded&#39;
            }
        ]}
        
        # You can also return attributes
        return attributes
        
        
    def set_style_attributes(self):
        
        # You can set a dictionary directly or return a dict like bellow
        self.style_attributes = {
            &#39;width&#39;: &#39;1/3&#39;
        }
        
        # or import `style_attributes` dataclass
        # from licenseware.report_components.style_attributes import style_attributes as styles
        style_attributes = self.build_style_attributes([
            styles.WIDTH_ONE_THIRD
            #etc
        ])
        
        return style_attributes


    def set_allowed_filters(self):
        # Provide a list of allowed filters for this component
        return [
            # You can use the build_filter method
            self.build_filter(
                column=&#34;device_name&#34;, 
                allowed_filters=[
                    filters.EQUALS, filters.CONTAINS, filters.IN_LIST
                ], 
                visible_name=&#34;Device Name&#34;, 
                # validate:bool = True # This will check field_name and allowed_filters
            ),
            # or you can create the dictionary like bellow (disadvantage no autocomplete, no checks)
            {
                &#34;column&#34;: &#34;database_name&#34;,
                &#34;allowed_filters&#34;: [
                    &#34;equals&#34;, &#34;contains&#34;, &#34;in_list&#34;
                ],
                &#34;visible_name&#34;: &#34;Database Name&#34;
            }
        
        ]
        
    
        

virtual_overview = VirtualOverview(
    title=&#34;Overview&#34;,
    component_id=&#34;virtual_overview&#34;,
    component_type=&#39;summary&#39;
)


```

Now `virtual_overview` is our `report_component`.

We can later register the component straight to the `App` or `Report`
```py
ifmp_app.register_report_component(virtual_overview)
```

## Creating the `Report`

The report can hold one or more report components. 


```py
#report.py

from licenseware.report_builder import ReportBuilder
from ...some_report_component import virtual_overview


virtualization_details_report = ReportBuilder(
    name=&#34;Virtualization Details&#34;,
    report_id=&#34;virtualization_details&#34;,
    description=&#34;This report gives you a detailed view of your virtual infrastructure.&#34;,
    connected_apps=[&#39;ifmp-service&#39;],
    report_components=[
        virtual_overview        
    ]
)

```

We can later add the report to our main `App`

```py
ifmp_app.register_report(virtualization_details_report)
```

Reports api will be handled by the `ifmp_app` instance.






&lt;a name=&#34;custom-namespaces&#34;&gt;&lt;/a&gt;
# Custom namespaces


We are not restricted using just the apis generated from `AppBuilder` we can add new custom ones to `App`/`ifmp_app`.



```py
#some_namespace.py

from flask_restx import Namespace, Resource


ns = Namespace(
    name=&#34;Custom&#34;, 
    description=&#34;This is a custom namespace with the app prefix&#34;
)

@ns.route(&#34;/custom-api-route&#34;)
class CustomApiRoute(Resource):    
    @ns.doc(id=&#34;custom&#34;)
    def get(self):
        return &#34;custom-api-route&#34;

```

We can later import the namespace created to our `main` file

```py
ifmp_app.register_namespace(custom_ns, path=&#39;/ns-prefix&#39;)
```

`ifmp_app` will make sure it will have the app prefix.

If the custom namespace created is repetead for all apps consider adding it to `app_builder` package.







&lt;a name=&#34;endpoints-from-simple-functions&#34;&gt;&lt;/a&gt;
# Endpoints from simple functions


Class `EndpointBuilder` can be used to generate endpoints from simple functions.
The function name will be used to extract the http method and the route path (`get_custom_data_from_mongo` --&gt;
`GET` http-method, `/get_custom_data_from_mongo` path-route)

```py
#func.py

from licenseware.endpoint_builder import EndpointBuilder

def get_custom_data_from_mongo(flask_request):
    &#34;&#34;&#34; Custom documentation &#34;&#34;&#34;
    
    # Some logic here

    return &#34;Some data&#34;


custom_func_endpoint = EndpointBuilder(get_custom_data_from_mongo)
```

The function will receive a flask request as a parameter and will be added to `/custom_endpoint/get_custom_data_from_mongo`

Later in our `main` file: 
```py
ifmp_app.register_endpoint(custom_func_endpoint)
```









&lt;a name=&#34;the-main-file&#34;&gt;&lt;/a&gt;
# The `main` file


In the main file or in `create_app` builder function (where Flask is instantiated) we can initialize the `App` with `ifmp_app.init_app(app)` where `app` is the Flask instance. 

When `init_app` is invoked all endpoinds defined in `app_builder` will be created and registration information will be sent to registry-service if `register=True`. You can also initiate the registration to registry-service process with `ifmp_app.register_app()` 


```py

from flask import Flask
from ...app_definition import ifmp_app
from ...uploader import rv_tools_uploader
from ...some_report_component import virtual_overview
from ...report import virtualization_details_report
from ...some_namespace import ns as custom_ns
from ...func import custom_func_endpoint


app = Flask(__name__)


# These can be placed in `app_definition`  

ifmp_app.register_uploader(rv_tools_uploader)
ifmp_app.register_report_component(virtual_overview)
ifmp_app.register_report(virtualization_details_report)
ifmp_app.register_namespace(custom_ns, path=&#39;/ns-prefix&#39;)
ifmp_app.register_endpoint(custom_func_endpoint)


# Just like any other flask extension
ifmp_app.init_app(app, register=True)    
    

if __name__ == &#34;__main__&#34;:    
    app.run(port=4000, debug=True)


```




&lt;a name=&#34;licenseware-cli&#34;&gt;&lt;/a&gt;
# Licenseware CLI

The licenseware sdk provides also some CLI utilities for quick development. 
You can invoke the cli with by typing licenseware in the terminal followed by --help for docs.

```

$ licenseware --help
Usage: licenseware [OPTIONS] COMMAND [ARGS]...

  Useful CLI commands for automatic code generation, files and folders
  creation.

Options:
  --install-completion [bash|zsh|fish|powershell|pwsh]
                                  Install completion for the specified shell.
  --show-completion [bash|zsh|fish|powershell|pwsh]
                                  Show completion for the specified shell, to
                                  copy it or customize the installation.

  --help                          Show this message and exit.

Commands:
  build-docs            Build app html docs
  build-sdk-docs        Build licenseware sdk html docs
  create-tests          Create tests from swagger docs Command example: &gt;&gt;...
  new-app               Given app_id build a new app The package structure...
  new-report            Given report_id build a new report The package...
  new-report-component  Given component_id and component_type build a new...
  new-uploader          Given uploader_id build a new uploader The package...
  recreate-files        Recreate files that are needed but missing

```

See help for a command by specifing the command name followed by --help

```
$ licenseware new-report-component --help

```

## Create the app from CLI 

Create the app from the terminal. 
Argument `new-app` requires an `app_id`. The id will be placed in the `.env` file.

```bash

licenseware new-app ifmp

``` 

The entire app structure will be generated 

```bash
.
├── app
│   ├── common
│   │   └── __init__.py
│   ├── controllers
│   │   └── __init__.py
│   ├── __init__.py
│   ├── report_components
│   │   └── __init__.py
│   ├── reports
│   │   └── __init__.py
│   ├── serializers
│   │   └── __init__.py
│   ├── services
│   │   └── __init__.py
│   ├── uploaders
│   │   └── __init__.py
│   └── utils
│       └── __init__.py
├── app.log
├── CHANGELOG.md
├── cloudformation-templates
│   ├── odb-api_prod.yml
│   └── odb-api.yml
├── deploy
│   └── jupyter
│       ├── docker-compose.yml
│       └── requirements.txt
├── docker-compose.yml
├── docker-entrypoint.sh
├── Dockerfile
├── Dockerfile.stack
├── main.py
├── makefile
├── Procfile
├── Procfile.stack
├── README.md
├── requirements-dev.txt
├── requirements-tests.txt
├── requirements.txt
├── setup.py
├── test_files
├── tests
│   ├── __init__.py
│   └── test_starter.py
├── tox.ini
└── version.txt

14 directories, 32 files
```

All imports will be handled by the CLI when you create a new uploader, report or report_component from the terminal.


## Create a new uploader from CLI 

Argument `new-uploader` needs a `uploader_id`

```bash

licenseware new-uploader rv_tools

``` 

```
.uploaders
├── __init__.py
└── rv_tools
    ├── __init__.py
    ├── validator.py
    └── worker.py
```

Uploader id will be `rv_tools`. Each uploader has a validator and a worker. 
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.




## Create a new report from CLI 

Argument `new-report` needs a `report_id`

```bash

licenseware new-report virtualization_details

``` 

```
.reports
├── __init__.py
└── virtualization_details
    ├── __init__.py
    └── virtualization_details.py
```

Report id will be `virtualization_details`.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.




## Create a new report component from CLI 

Argument `new-report-component` needs a `component_id` and a `component_type`.

```bash

licenseware new-report-component virtual_overview summary

``` 

```
.report_components
├── __init__.py
└── virtual_overview
    ├── __init__.py
    └── virtual_overview.py
```

Component id will be `virtual_overview` and it&#39;s component type will be `summary`.
All imports an routes will be handled by the licenseware sdk.
To sparse the logic you can create multiple sub-packages/modules.


&lt;a name=&#34;working-on-sdk&#34;&gt;&lt;/a&gt;
# Working on SDK

- Each new feature should be placed in a package
- Add only features that apply to all or most apps
- # TODO




# Load testing

[baton docs](https://github.com/americanexpress/baton)

```bash
baton -u http://localhost/appid/yourendpoint -c 10 -r 10000
```

# TODO


&#39;&#39;&#39;

from licenseware.utils.miscellaneous import set_environment_variables


set_environment_variables(env_path=&#34;./.env&#34;)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code></dt>
<dd>
<div class="desc"><p>In the <code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code> package we define the <code>app</code> and build the api …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.auth" href="auth/index.html">licenseware.auth</a></code></dt>
<dd>
<div class="desc"><p>Here is the authentification class for machines and services.
Authentification credentials will be taken from <code>.env</code> file …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.cli" href="cli/index.html">licenseware.cli</a></code></dt>
<dd>
<div class="desc"><p>This module provides useful CLI commands for automatic creation of files/folders/packages …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.common" href="common/index.html">licenseware.common</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.decorators" href="decorators/index.html">licenseware.decorators</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.dependencies" href="dependencies/index.html">licenseware.dependencies</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.download" href="download/index.html">licenseware.download</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.editable_table" href="editable_table/index.html">licenseware.editable_table</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.endpoint_builder" href="endpoint_builder/index.html">licenseware.endpoint_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.feature_builder" href="feature_builder/index.html">licenseware.feature_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.history" href="history/index.html">licenseware.history</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.mongodata" href="mongodata/index.html">licenseware.mongodata</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.notifications" href="notifications/index.html">licenseware.notifications</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.quota" href="quota/index.html">licenseware.quota</a></code></dt>
<dd>
<div class="desc"><p>This package is reponsible for updating the quota per <code>user_id</code> at each upload …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.registry_service" href="registry_service/index.html">licenseware.registry_service</a></code></dt>
<dd>
<div class="desc"><p>All calls to registry service should be added in this package</p></div>
</dd>
<dt><code class="name"><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.report_snapshot" href="report_snapshot/index.html">licenseware.report_snapshot</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.repository" href="repository/index.html">licenseware.repository</a></code></dt>
<dd>
<div class="desc"><p>Usage: …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.resources" href="resources/index.html">licenseware.resources</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.schema_namespace" href="schema_namespace/index.html">licenseware.schema_namespace</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.tenants" href="tenants/index.html">licenseware.tenants</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.test_helpers" href="test_helpers/index.html">licenseware.test_helpers</a></code></dt>
<dd>
<div class="desc"><p>Controllers (api declarations) …</p></div>
</dd>
<dt><code class="name"><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.uploader_validator" href="uploader_validator/index.html">licenseware.uploader_validator</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="licenseware.utils" href="utils/index.html">licenseware.utils</a></code></dt>
<dd>
<div class="desc"><p>In this package you will find various functions and classes that can be used when needed.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#licenseware-sdk">Licenseware SDK</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#quickstart">Quickstart</a><ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#sdk-new-version-release">SDK new version release</a></li>
<li><a href="#a-minimal-app">A minimal app</a></li>
</ul>
</li>
<li><a href="#what-is-an-app">What is an App?</a></li>
<li><a href="#set-environment-variables">Set environment variables</a></li>
<li><a href="#app-declaration">App declaration</a></li>
<li><a href="#uploader-declaration">Uploader declaration</a><ul>
<li><a href="#creating-the-worker_function">Creating the worker_function</a></li>
<li><a href="#creating-the-validator_class">Creating the validator_class</a></li>
</ul>
</li>
<li><a href="#report-declaration">Report declaration</a><ul>
<li><a href="#creating-the-report-component">Creating the Report component</a></li>
<li><a href="#creating-the-report">Creating the Report</a></li>
</ul>
</li>
<li><a href="#custom-namespaces">Custom namespaces</a></li>
<li><a href="#endpoints-from-simple-functions">Endpoints from simple functions</a></li>
<li><a href="#the-main-file">The main file</a></li>
<li><a href="#licenseware-cli">Licenseware CLI</a><ul>
<li><a href="#create-the-app-from-cli">Create the app from CLI</a></li>
<li><a href="#create-a-new-uploader-from-cli">Create a new uploader from CLI</a></li>
<li><a href="#create-a-new-report-from-cli">Create a new report from CLI</a></li>
<li><a href="#create-a-new-report-component-from-cli">Create a new report component from CLI</a></li>
</ul>
</li>
<li><a href="#working-on-sdk">Working on SDK</a></li>
<li><a href="#todo">TODO</a></li>
<li><a href="#load-testing">Load testing</a></li>
<li><a href="#todo_1">TODO</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="licenseware.app_builder" href="app_builder/index.html">licenseware.app_builder</a></code></li>
<li><code><a title="licenseware.auth" href="auth/index.html">licenseware.auth</a></code></li>
<li><code><a title="licenseware.cli" href="cli/index.html">licenseware.cli</a></code></li>
<li><code><a title="licenseware.common" href="common/index.html">licenseware.common</a></code></li>
<li><code><a title="licenseware.decorators" href="decorators/index.html">licenseware.decorators</a></code></li>
<li><code><a title="licenseware.dependencies" href="dependencies/index.html">licenseware.dependencies</a></code></li>
<li><code><a title="licenseware.download" href="download/index.html">licenseware.download</a></code></li>
<li><code><a title="licenseware.editable_table" href="editable_table/index.html">licenseware.editable_table</a></code></li>
<li><code><a title="licenseware.endpoint_builder" href="endpoint_builder/index.html">licenseware.endpoint_builder</a></code></li>
<li><code><a title="licenseware.feature_builder" href="feature_builder/index.html">licenseware.feature_builder</a></code></li>
<li><code><a title="licenseware.history" href="history/index.html">licenseware.history</a></code></li>
<li><code><a title="licenseware.mongodata" href="mongodata/index.html">licenseware.mongodata</a></code></li>
<li><code><a title="licenseware.notifications" href="notifications/index.html">licenseware.notifications</a></code></li>
<li><code><a title="licenseware.quota" href="quota/index.html">licenseware.quota</a></code></li>
<li><code><a title="licenseware.registry_service" href="registry_service/index.html">licenseware.registry_service</a></code></li>
<li><code><a title="licenseware.report_builder" href="report_builder/index.html">licenseware.report_builder</a></code></li>
<li><code><a title="licenseware.report_components" href="report_components/index.html">licenseware.report_components</a></code></li>
<li><code><a title="licenseware.report_snapshot" href="report_snapshot/index.html">licenseware.report_snapshot</a></code></li>
<li><code><a title="licenseware.repository" href="repository/index.html">licenseware.repository</a></code></li>
<li><code><a title="licenseware.resources" href="resources/index.html">licenseware.resources</a></code></li>
<li><code><a title="licenseware.schema_namespace" href="schema_namespace/index.html">licenseware.schema_namespace</a></code></li>
<li><code><a title="licenseware.tenants" href="tenants/index.html">licenseware.tenants</a></code></li>
<li><code><a title="licenseware.test_helpers" href="test_helpers/index.html">licenseware.test_helpers</a></code></li>
<li><code><a title="licenseware.uploader_builder" href="uploader_builder/index.html">licenseware.uploader_builder</a></code></li>
<li><code><a title="licenseware.uploader_validator" href="uploader_validator/index.html">licenseware.uploader_validator</a></code></li>
<li><code><a title="licenseware.utils" href="utils/index.html">licenseware.utils</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>