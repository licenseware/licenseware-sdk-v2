<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>licenseware.mongodata.mongodata API documentation</title>
<meta name="description" content="Abstraction and validation of inserted data in mongodb â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>licenseware.mongodata.mongodata</code></h1>
</header>
<section id="section-intro">
<p>Abstraction and validation of inserted data in mongodb</p>
<p>from licenseware import mongodata
or
from licenseware import mongodata as m</p>
<p>Available functions:
- get_collection
- insert
- fetch
- update
- delete
- aggregate
- delete
- delete_collection
- document_count</p>
<p>Needs the following environment variables:
- MONGO_DATABASE_NAME
- MONGO_CONNECTION_STRING
- MONGO_COLLECTION_NAME (optional)</p>
<p>Pagination</p>
<p>For pagination make sure to include the special field <code>__pagination__</code> on <code>match</code> parameter like bellow: </p>
<pre><code class="language-py">
results = mongodata.fetch(
    match={
            &quot;__pagination__&quot;: {
                &quot;limit&quot;: 20,
                &quot;skip&quot;: 0
            }
        },
    collection=self.collection
)

</code></pre>
<ul>
<li><code>limit</code> - is the mongo limit;</li>
<li><code>skip</code> - is the mongo skip; </li>
</ul>
<p>Start with <code>skip</code> value 0 and increase that value on each iteration.
If <code>__pagination__</code> is not found on match pagination will not be applied.</p>
<p>You can also use for pagination <code>limit</code> and <code>skip</code> paramters provided by the fetch function.</p>
<p>This would be the first iteration:</p>
<pre><code class="language-py">
skip = 0

results = mongodata.fetch(
    match={},
    limit = 20,
    skip = skip,
    collection=self.collection
)

skip += len(results)
</code></pre>
<p>This would be the second iteration:</p>
<pre><code class="language-py">results = mongodata.fetch(
    match={},
    limit = 20,
    skip = skip,
    collection=self.collection
)

skip += len(results)
</code></pre>
<p>And the same is for the next iterations until <code>len(results)</code> is 0.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

Abstraction and validation of inserted data in mongodb


from licenseware import mongodata
or
from licenseware import mongodata as m

Available functions:
- get_collection
- insert
- fetch
- update
- delete
- aggregate
- delete
- delete_collection
- document_count

Needs the following environment variables:
- MONGO_DATABASE_NAME
- MONGO_CONNECTION_STRING
- MONGO_COLLECTION_NAME (optional)


Pagination

For pagination make sure to include the special field `__pagination__` on `match` parameter like bellow: 

```py

results = mongodata.fetch(
    match={
            &#34;__pagination__&#34;: {
                &#34;limit&#34;: 20,
                &#34;skip&#34;: 0
            }
        },
    collection=self.collection
)

```

- `limit` - is the mongo limit;
- `skip` - is the mongo skip; 


Start with `skip` value 0 and increase that value on each iteration.
If `__pagination__` is not found on match pagination will not be applied.


You can also use for pagination `limit` and `skip` paramters provided by the fetch function.


This would be the first iteration:

```py

skip = 0

results = mongodata.fetch(
    match={},
    limit = 20,
    skip = skip,
    collection=self.collection
)

skip += len(results)
```

This would be the second iteration:

```py
results = mongodata.fetch(
    match={},
    limit = 20,
    skip = skip,
    collection=self.collection
)

skip += len(results)
```

And the same is for the next iterations until `len(results)` is 0.


&#34;&#34;&#34;

import os
import json
from typing import Union, Tuple, List, Dict
from uuid import UUID
from pymongo import MongoClient, ASCENDING, DESCENDING
from pymongo.collection import Collection
from bson.json_util import dumps
from bson.objectid import ObjectId
from pymongo.write_concern import WriteConcern
from pymongo.read_concern import ReadConcern

from licenseware.utils.logger import log


def validate_data(schema, data):
    &#34;&#34;&#34;
        Using Marshmallow schema class to validate data (dict or list of dicts) 
    &#34;&#34;&#34;

    if isinstance(data, dict):
        data = schema().load(data)

    if isinstance(data, list):
        data = schema(many=True).load(data)

    return data


def valid_uuid(uuid_string):
    try:
        UUID(uuid_string)
        return True
    except ValueError:
        return False


def valid_object_id(oid_string):
    try:
        ObjectId(oid_string)
        return True
    except:
        return False


def parse_oid(oid):
    if isinstance(oid, ObjectId):
        return json.loads(dumps(oid))[&#39;$oid&#39;]
    return oid


def parse_doc(doc):
    if not isinstance(doc, dict):
        return doc
    if not &#34;_id&#34; in doc:
        return doc

    return dict(doc, **{&#34;_id&#34;: parse_oid(doc[&#34;_id&#34;])})


def parse_match(match):
    # query_tuple - select only fields
    # distinct_key - select distinct fields

    categ = {
        &#39;_id&#39;: None,
        &#39;oid&#39;: None,
        &#39;uid&#39;: None,
        &#39;distinct_key&#39;: None,
        &#39;query_tuple&#39;: None,
        &#39;query&#39;: None
    }

    if isinstance(match, dict):

        if &#39;_id&#39; in match:
            if valid_object_id(match[&#39;_id&#39;]):
                match[&#39;_id&#39;] = ObjectId(match[&#39;_id&#39;])

        categ[&#39;query&#39;] = match

    elif isinstance(match, str):
        if valid_uuid(match):
            match = {&#34;_id&#34;: match}
            categ[&#39;uid&#39;] = match
        elif valid_object_id(match):
            match = {&#34;_id&#34;: ObjectId(match)}
            categ[&#39;oid&#39;] = match
        else:
            categ[&#39;distinct_key&#39;] = match

        categ[&#39;_id&#39;] = categ[&#39;uid&#39;] or categ[&#39;oid&#39;]

    elif (isinstance(match, tuple) or isinstance(match, list)) and len(match) == 2:
        categ[&#39;query_tuple&#39;] = match
    else:
        raise ValueError(&#34;Can&#39;t parse match query&#34;)

    return categ


def get_db_name(db_name):
    if db_name:
        return db_name
    default_db = os.getenv(&#34;MONGO_DB_NAME&#34;) or os.getenv(
        &#34;MONGO_DATABASE_NAME&#34;) or &#34;db&#34;
    return default_db


def return_collection_name(collection):
    if collection:
        return collection
    default_collection = os.getenv(&#34;MONGO_COLLECTION_NAME&#34;) or &#34;Data&#34;
    return collection or default_collection


class Connect(object):
    @staticmethod
    def get_connection():
        return MongoClient(os.getenv(&#34;MONGO_CONNECTION_STRING&#34;))


def get_collection(collection, db_name=None):
    &#34;&#34;&#34;
        Gets the collection on which mongo CRUD operations can be performed

        
    &#34;&#34;&#34;

    default_db = os.getenv(&#34;MONGO_DB_NAME&#34;) or os.getenv(
        &#34;MONGO_DATABASE_NAME&#34;) or &#34;db&#34;
    default_collection = os.getenv(&#34;MONGO_COLLECTION_NAME&#34;) or &#34;Data&#34;

    with Connect.get_connection() as mongo_connection:
        collection = collection or default_collection
        db_name = db_name or default_db

        if not all([db_name, collection, mongo_connection]):
            raise Exception(&#34;Can&#39;t create connection to mongo.&#34;)

        collection = mongo_connection[db_name][collection]

        return collection


def insert(schema, collection, data, db_name=None):
    &#34;&#34;&#34;
        Insert validated documents in database.

        :schema     - Marshmallow schema class used to validate `data`
        :collection - collection name, schema name will be taken if not present
        :data       - data in dict or list of dicts format
        :db_name    - specify other db if needed, by default is MONGO_DATABASE_NAME from .env

        returns a list of ids inserted in the database in the order they were added
        
    &#34;&#34;&#34;
    # log.debug(&#34;Incoming data:&#34;)
    # log.debug(data)

    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        # log.debug(collection)
        if not isinstance(collection, Collection):
            return collection

        data = validate_data(schema, data)
        # log.debug(&#34;Data saved to DB&#34;)
        # log.debug(data)

        if isinstance(data, dict):
            _oid_inserted = collection.with_options(
                write_concern=WriteConcern(&#34;majority&#34;)).insert_one(data).inserted_id
            inserted_id = parse_oid(_oid_inserted)
            return [inserted_id]

        if isinstance(data, list):
            inserted_ids = collection.with_options(
                write_concern=WriteConcern(&#34;majority&#34;)).insert_many(data).inserted_ids
            return [parse_oid(oid) for oid in inserted_ids]

        raise Exception(f&#34;Can&#39;t interpret validated data: {data}&#34;)


def get_sortli(sortdict: dict):
    if sortdict is None: return

    sortli = [
        (field, ascdesc)
        for field, ascdesc in sortdict.items()
    ]

    return sortli


def fetch(match: Union[dict, Tuple[Dict[str, str], Dict[str, int]]], collection: str, as_list: bool = True, limit: int = None, skip: int = None,
          sortby: Dict[str, int] = None, db_name: str = None):
    &#34;&#34;&#34;
        Get data from mongo, based on match dict or string id.

        :match      - _id as string (will return a dict)
                    - mongo dict filter (will return a list of results)
                    - field_name as string (will return distinct values for that field)

        :collection - collection name
        :as_list    - set as_list to false to get a generator
        :db_name    - specify other db if needed by default is MONGO_DATABASE_NAME from .env

    &#34;&#34;&#34;

    # TODO - needs refatoring (to much going on)

    pagination = None
    if isinstance(match, dict):
        pagination = match.pop(&#34;__pagination__&#34;, None)

    match = parse_match(match)
    sortbylist = get_sortli(sortby)

    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)

    log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {match}&#34;)

    with Connect.get_connection() as mongo_connection:
        collection: MongoClient = mongo_connection[db_name][collection_name]
        # log.debug(collection)
        if not isinstance(collection, Collection):
            return collection

        if match[&#39;_id&#39;]:
            found_docs = collection.find(match[&#39;_id&#39;]) if sortbylist is None else collection.find(match[&#39;_id&#39;]).sort(
                sortbylist)
            doc = []
            if found_docs: doc = list(found_docs)[0]
            if match[&#39;oid&#39;]: doc = parse_doc(doc)
            return doc

        if match[&#39;distinct_key&#39;]:
            found_docs = collection.with_options(
                read_concern=ReadConcern(&#34;majority&#34;)).distinct(match[&#39;distinct_key&#39;])

        elif match[&#39;query_tuple&#39;]:

            if pagination:

                if sortbylist is None:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

                else:
                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .sort(sortbylist) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

            elif limit is not None and skip is not None:

                if sortbylist is None:
                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .skip(skip) \
                        .limit(limit)
                else:
                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .sort(sortbylist) \
                        .skip(skip) \
                        .limit(limit)

            else:
                if sortbylist is None:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(*match[&#39;query_tuple&#39;])
                else:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(*match[&#39;query_tuple&#39;]).sort(sortbylist)

        else:

            if pagination:

                if sortbylist is None:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

                else:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .sort(sortbylist) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

            elif limit is not None and skip is not None:

                if sortbylist is None:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .skip(skip) \
                        .limit(limit)

                else:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .sort(sortbylist) \
                        .skip(skip) \
                        .limit(limit)

            else:

                if sortbylist is None:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(match[&#39;query&#39;])
                else:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(match[&#39;query&#39;]).sort(sortbylist)

        if as_list:
            return [parse_doc(doc) for doc in found_docs]

        return (parse_doc(doc) for doc in found_docs)


def aggregate(pipeline, collection, as_list=True, db_name=None):
    &#34;&#34;&#34;
        Fetch documents based on pipeline queries.
        https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/

        :pipeline   - list of query stages
        :collection - collection name
        :as_list    - set as_list to false to get a generator
        :db_name    - specify other db if needed by default is MONGO_DATABASE_NAME from .env

    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)

    log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {pipeline}&#34;)

    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        if not isinstance(collection, Collection):
            return collection

        found_docs = collection.with_options(read_concern=ReadConcern(
            &#34;majority&#34;)).aggregate(pipeline, allowDiskUse=True)

        if as_list:
            return [parse_doc(doc) for doc in found_docs]

        return (parse_doc(doc) for doc in found_docs)


def _append_query(dict_: dict) -&gt; dict:
    &#34;&#34;&#34; 
        Force append to mongo document 
    &#34;&#34;&#34;

    _id = dict_.pop(&#34;_id&#34;, None)

    # log.warning(_id)

    q = {&#39;$set&#39;: {}, &#39;$addToSet&#39;: {}}
    for k in dict_:

        # if isinstance(dict_[k], str):
        #     q[&#39;$set&#39;].update({k: dict_[k]})

        if isinstance(dict_[k], dict):
            for key in dict_[k]:
                key_ = &#34;.&#34;.join([k, key])  # files.status
                q[&#39;$set&#39;].update({key_: dict_[k][key]})

        elif isinstance(dict_[k], list) and dict_[k]:
            q[&#39;$addToSet&#39;].update({k: {}})
            q[&#39;$addToSet&#39;][k].update({&#34;$each&#34;: dict_[k]})

        else:
            q[&#39;$set&#39;].update({k: dict_[k]})

    if not q[&#39;$addToSet&#39;]:
        del q[&#39;$addToSet&#39;]
    if not q[&#39;$set&#39;]:
        del q[&#39;$set&#39;]

    # log_dict(q)

    return q or dict_


def update(schema, match, new_data, collection, append=False, db_name=None):
    &#34;&#34;&#34;
        Update documents based on match query.

        :schema      - Marshmallow schema class
        :match       - id as string or dict filter query
        :new_data    - data dict which needs to be updated
        :collection  - collection name
        :append      - if true will APPEND new data to existing fields, if false will SET new data to fields  
        :db_name     - specify other db if needed by default is MONGO_DATABASE_NAME from .env

        returns number of modified documents

    &#34;&#34;&#34;
    # log.debug(&#34;Incoming data:&#34;)
    # log.debug(new_data)

    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        match = parse_match(match)
        match = match[&#39;query&#39;] or match[&#39;_id&#39;]
        if not match:
            match = match[&#39;_id&#39;] = match[&#39;distinct_key&#39;]

        new_data = validate_data(schema, new_data)
        # log.debug(&#34;Data saved to DB&#34;)
        # log.debug(new_data)

        _filter = {&#34;_id&#34;: match[&#34;_id&#34;]} if &#34;_id&#34; in match else match

        log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {_filter}&#34;)

        updated_docs_nbr = collection.with_options(write_concern=WriteConcern(&#34;majority&#34;)).update_many(
            filter=_filter,
            update=_append_query(new_data) if append else {&#34;$set&#34;: new_data},
            upsert=True
        ).modified_count

        return updated_docs_nbr


def delete(match, collection, db_name=None):
    &#34;&#34;&#34;

        Delete documents based on match query.

        :match       - id as string or dict filter query,           
        :collection  - collection name
        :db_name     - specify other db if needed by default is MONGO_DATABASE_NAME from .env

        returns number of deleted documents

        

    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)

    log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {match}&#34;)

    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        match = parse_match(match)

        if not isinstance(collection, Collection):
            return collection

        deleted_docs_nbr = collection.with_options(write_concern=WriteConcern(&#34;majority&#34;)).delete_many(
            filter=match[&#39;query&#39;] or match[&#39;_id&#39;],
        ).deleted_count

        return deleted_docs_nbr


def delete_collection(collection, db_name=None):
    &#34;&#34;&#34;
        Delete a collection from the database.
    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        if not isinstance(collection, Collection):
            return collection

        res = collection.with_options(
            write_concern=WriteConcern(&#34;majority&#34;)).drop()
        return 1 if res is None else 0


def distinct(match, key, collection, db_name=None):
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        return collection.distinct(key, match)


def document_count(match, collection, db_name=None):
    &#34;&#34;&#34;
        Delete a collection from the database.
    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        if not isinstance(collection, Collection):
            return collection

        return collection.with_options(
            write_concern=WriteConcern(&#34;majority&#34;)).count_documents(filter=match)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="licenseware.mongodata.mongodata.aggregate"><code class="name flex">
<span>def <span class="ident">aggregate</span></span>(<span>pipeline, collection, as_list=True, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch documents based on pipeline queries.
<a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/">https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/</a></p>
<p>:pipeline
- list of query stages
:collection - collection name
:as_list
- set as_list to false to get a generator
:db_name
- specify other db if needed by default is MONGO_DATABASE_NAME from .env</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregate(pipeline, collection, as_list=True, db_name=None):
    &#34;&#34;&#34;
        Fetch documents based on pipeline queries.
        https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/

        :pipeline   - list of query stages
        :collection - collection name
        :as_list    - set as_list to false to get a generator
        :db_name    - specify other db if needed by default is MONGO_DATABASE_NAME from .env

    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)

    log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {pipeline}&#34;)

    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        if not isinstance(collection, Collection):
            return collection

        found_docs = collection.with_options(read_concern=ReadConcern(
            &#34;majority&#34;)).aggregate(pipeline, allowDiskUse=True)

        if as_list:
            return [parse_doc(doc) for doc in found_docs]

        return (parse_doc(doc) for doc in found_docs)</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>match, collection, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete documents based on match query.</p>
<p>:match
- id as string or dict filter query,
<br>
:collection
- collection name
:db_name
- specify other db if needed by default is MONGO_DATABASE_NAME from .env</p>
<p>returns number of deleted documents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(match, collection, db_name=None):
    &#34;&#34;&#34;

        Delete documents based on match query.

        :match       - id as string or dict filter query,           
        :collection  - collection name
        :db_name     - specify other db if needed by default is MONGO_DATABASE_NAME from .env

        returns number of deleted documents

        

    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)

    log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {match}&#34;)

    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        match = parse_match(match)

        if not isinstance(collection, Collection):
            return collection

        deleted_docs_nbr = collection.with_options(write_concern=WriteConcern(&#34;majority&#34;)).delete_many(
            filter=match[&#39;query&#39;] or match[&#39;_id&#39;],
        ).deleted_count

        return deleted_docs_nbr</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.delete_collection"><code class="name flex">
<span>def <span class="ident">delete_collection</span></span>(<span>collection, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a collection from the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_collection(collection, db_name=None):
    &#34;&#34;&#34;
        Delete a collection from the database.
    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        if not isinstance(collection, Collection):
            return collection

        res = collection.with_options(
            write_concern=WriteConcern(&#34;majority&#34;)).drop()
        return 1 if res is None else 0</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.distinct"><code class="name flex">
<span>def <span class="ident">distinct</span></span>(<span>match, key, collection, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distinct(match, key, collection, db_name=None):
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        return collection.distinct(key, match)</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.document_count"><code class="name flex">
<span>def <span class="ident">document_count</span></span>(<span>match, collection, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a collection from the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def document_count(match, collection, db_name=None):
    &#34;&#34;&#34;
        Delete a collection from the database.
    &#34;&#34;&#34;
    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        if not isinstance(collection, Collection):
            return collection

        return collection.with_options(
            write_concern=WriteConcern(&#34;majority&#34;)).count_documents(filter=match)</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>match:Â Union[dict,Â Tuple[Dict[str,Â str],Â Dict[str,Â int]]], collection:Â str, as_list:Â boolÂ =Â True, limit:Â intÂ =Â None, skip:Â intÂ =Â None, sortby:Â Dict[str,Â int]Â =Â None, db_name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get data from mongo, based on match dict or string id.</p>
<p>:match
- _id as string (will return a dict)
- mongo dict filter (will return a list of results)
- field_name as string (will return distinct values for that field)</p>
<p>:collection - collection name
:as_list
- set as_list to false to get a generator
:db_name
- specify other db if needed by default is MONGO_DATABASE_NAME from .env</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(match: Union[dict, Tuple[Dict[str, str], Dict[str, int]]], collection: str, as_list: bool = True, limit: int = None, skip: int = None,
          sortby: Dict[str, int] = None, db_name: str = None):
    &#34;&#34;&#34;
        Get data from mongo, based on match dict or string id.

        :match      - _id as string (will return a dict)
                    - mongo dict filter (will return a list of results)
                    - field_name as string (will return distinct values for that field)

        :collection - collection name
        :as_list    - set as_list to false to get a generator
        :db_name    - specify other db if needed by default is MONGO_DATABASE_NAME from .env

    &#34;&#34;&#34;

    # TODO - needs refatoring (to much going on)

    pagination = None
    if isinstance(match, dict):
        pagination = match.pop(&#34;__pagination__&#34;, None)

    match = parse_match(match)
    sortbylist = get_sortli(sortby)

    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)

    log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {match}&#34;)

    with Connect.get_connection() as mongo_connection:
        collection: MongoClient = mongo_connection[db_name][collection_name]
        # log.debug(collection)
        if not isinstance(collection, Collection):
            return collection

        if match[&#39;_id&#39;]:
            found_docs = collection.find(match[&#39;_id&#39;]) if sortbylist is None else collection.find(match[&#39;_id&#39;]).sort(
                sortbylist)
            doc = []
            if found_docs: doc = list(found_docs)[0]
            if match[&#39;oid&#39;]: doc = parse_doc(doc)
            return doc

        if match[&#39;distinct_key&#39;]:
            found_docs = collection.with_options(
                read_concern=ReadConcern(&#34;majority&#34;)).distinct(match[&#39;distinct_key&#39;])

        elif match[&#39;query_tuple&#39;]:

            if pagination:

                if sortbylist is None:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

                else:
                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .sort(sortbylist) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

            elif limit is not None and skip is not None:

                if sortbylist is None:
                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .skip(skip) \
                        .limit(limit)
                else:
                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(*match[&#39;query_tuple&#39;]) \
                        .sort(sortbylist) \
                        .skip(skip) \
                        .limit(limit)

            else:
                if sortbylist is None:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(*match[&#39;query_tuple&#39;])
                else:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(*match[&#39;query_tuple&#39;]).sort(sortbylist)

        else:

            if pagination:

                if sortbylist is None:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

                else:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .sort(sortbylist) \
                        .skip(pagination[&#39;skip&#39;]) \
                        .limit(pagination[&#39;limit&#39;])

            elif limit is not None and skip is not None:

                if sortbylist is None:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .skip(skip) \
                        .limit(limit)

                else:

                    found_docs = collection.with_options(read_concern=ReadConcern(&#34;majority&#34;)) \
                        .find(match[&#39;query&#39;]) \
                        .sort(sortbylist) \
                        .skip(skip) \
                        .limit(limit)

            else:

                if sortbylist is None:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(match[&#39;query&#39;])
                else:
                    found_docs = collection.with_options(
                        read_concern=ReadConcern(&#34;majority&#34;)).find(match[&#39;query&#39;]).sort(sortbylist)

        if as_list:
            return [parse_doc(doc) for doc in found_docs]

        return (parse_doc(doc) for doc in found_docs)</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.get_collection"><code class="name flex">
<span>def <span class="ident">get_collection</span></span>(<span>collection, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the collection on which mongo CRUD operations can be performed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_collection(collection, db_name=None):
    &#34;&#34;&#34;
        Gets the collection on which mongo CRUD operations can be performed

        
    &#34;&#34;&#34;

    default_db = os.getenv(&#34;MONGO_DB_NAME&#34;) or os.getenv(
        &#34;MONGO_DATABASE_NAME&#34;) or &#34;db&#34;
    default_collection = os.getenv(&#34;MONGO_COLLECTION_NAME&#34;) or &#34;Data&#34;

    with Connect.get_connection() as mongo_connection:
        collection = collection or default_collection
        db_name = db_name or default_db

        if not all([db_name, collection, mongo_connection]):
            raise Exception(&#34;Can&#39;t create connection to mongo.&#34;)

        collection = mongo_connection[db_name][collection]

        return collection</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.get_db_name"><code class="name flex">
<span>def <span class="ident">get_db_name</span></span>(<span>db_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_db_name(db_name):
    if db_name:
        return db_name
    default_db = os.getenv(&#34;MONGO_DB_NAME&#34;) or os.getenv(
        &#34;MONGO_DATABASE_NAME&#34;) or &#34;db&#34;
    return default_db</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.get_sortli"><code class="name flex">
<span>def <span class="ident">get_sortli</span></span>(<span>sortdict:Â dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sortli(sortdict: dict):
    if sortdict is None: return

    sortli = [
        (field, ascdesc)
        for field, ascdesc in sortdict.items()
    ]

    return sortli</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>schema, collection, data, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert validated documents in database.</p>
<p>:schema
- Marshmallow schema class used to validate <code>data</code>
:collection - collection name, schema name will be taken if not present
:data
- data in dict or list of dicts format
:db_name
- specify other db if needed, by default is MONGO_DATABASE_NAME from .env</p>
<p>returns a list of ids inserted in the database in the order they were added</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(schema, collection, data, db_name=None):
    &#34;&#34;&#34;
        Insert validated documents in database.

        :schema     - Marshmallow schema class used to validate `data`
        :collection - collection name, schema name will be taken if not present
        :data       - data in dict or list of dicts format
        :db_name    - specify other db if needed, by default is MONGO_DATABASE_NAME from .env

        returns a list of ids inserted in the database in the order they were added
        
    &#34;&#34;&#34;
    # log.debug(&#34;Incoming data:&#34;)
    # log.debug(data)

    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        # log.debug(collection)
        if not isinstance(collection, Collection):
            return collection

        data = validate_data(schema, data)
        # log.debug(&#34;Data saved to DB&#34;)
        # log.debug(data)

        if isinstance(data, dict):
            _oid_inserted = collection.with_options(
                write_concern=WriteConcern(&#34;majority&#34;)).insert_one(data).inserted_id
            inserted_id = parse_oid(_oid_inserted)
            return [inserted_id]

        if isinstance(data, list):
            inserted_ids = collection.with_options(
                write_concern=WriteConcern(&#34;majority&#34;)).insert_many(data).inserted_ids
            return [parse_oid(oid) for oid in inserted_ids]

        raise Exception(f&#34;Can&#39;t interpret validated data: {data}&#34;)</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.parse_doc"><code class="name flex">
<span>def <span class="ident">parse_doc</span></span>(<span>doc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_doc(doc):
    if not isinstance(doc, dict):
        return doc
    if not &#34;_id&#34; in doc:
        return doc

    return dict(doc, **{&#34;_id&#34;: parse_oid(doc[&#34;_id&#34;])})</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.parse_match"><code class="name flex">
<span>def <span class="ident">parse_match</span></span>(<span>match)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_match(match):
    # query_tuple - select only fields
    # distinct_key - select distinct fields

    categ = {
        &#39;_id&#39;: None,
        &#39;oid&#39;: None,
        &#39;uid&#39;: None,
        &#39;distinct_key&#39;: None,
        &#39;query_tuple&#39;: None,
        &#39;query&#39;: None
    }

    if isinstance(match, dict):

        if &#39;_id&#39; in match:
            if valid_object_id(match[&#39;_id&#39;]):
                match[&#39;_id&#39;] = ObjectId(match[&#39;_id&#39;])

        categ[&#39;query&#39;] = match

    elif isinstance(match, str):
        if valid_uuid(match):
            match = {&#34;_id&#34;: match}
            categ[&#39;uid&#39;] = match
        elif valid_object_id(match):
            match = {&#34;_id&#34;: ObjectId(match)}
            categ[&#39;oid&#39;] = match
        else:
            categ[&#39;distinct_key&#39;] = match

        categ[&#39;_id&#39;] = categ[&#39;uid&#39;] or categ[&#39;oid&#39;]

    elif (isinstance(match, tuple) or isinstance(match, list)) and len(match) == 2:
        categ[&#39;query_tuple&#39;] = match
    else:
        raise ValueError(&#34;Can&#39;t parse match query&#34;)

    return categ</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.parse_oid"><code class="name flex">
<span>def <span class="ident">parse_oid</span></span>(<span>oid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_oid(oid):
    if isinstance(oid, ObjectId):
        return json.loads(dumps(oid))[&#39;$oid&#39;]
    return oid</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.return_collection_name"><code class="name flex">
<span>def <span class="ident">return_collection_name</span></span>(<span>collection)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_collection_name(collection):
    if collection:
        return collection
    default_collection = os.getenv(&#34;MONGO_COLLECTION_NAME&#34;) or &#34;Data&#34;
    return collection or default_collection</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>schema, match, new_data, collection, append=False, db_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update documents based on match query.</p>
<p>:schema
- Marshmallow schema class
:match
- id as string or dict filter query
:new_data
- data dict which needs to be updated
:collection
- collection name
:append
- if true will APPEND new data to existing fields, if false will SET new data to fields<br>
:db_name
- specify other db if needed by default is MONGO_DATABASE_NAME from .env</p>
<p>returns number of modified documents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(schema, match, new_data, collection, append=False, db_name=None):
    &#34;&#34;&#34;
        Update documents based on match query.

        :schema      - Marshmallow schema class
        :match       - id as string or dict filter query
        :new_data    - data dict which needs to be updated
        :collection  - collection name
        :append      - if true will APPEND new data to existing fields, if false will SET new data to fields  
        :db_name     - specify other db if needed by default is MONGO_DATABASE_NAME from .env

        returns number of modified documents

    &#34;&#34;&#34;
    # log.debug(&#34;Incoming data:&#34;)
    # log.debug(new_data)

    db_name = get_db_name(db_name)
    collection_name = return_collection_name(collection)
    with Connect.get_connection() as mongo_connection:
        collection = mongo_connection[db_name][collection_name]
        match = parse_match(match)
        match = match[&#39;query&#39;] or match[&#39;_id&#39;]
        if not match:
            match = match[&#39;_id&#39;] = match[&#39;distinct_key&#39;]

        new_data = validate_data(schema, new_data)
        # log.debug(&#34;Data saved to DB&#34;)
        # log.debug(new_data)

        _filter = {&#34;_id&#34;: match[&#34;_id&#34;]} if &#34;_id&#34; in match else match

        log.info(f&#34;MONGO_QUERY [{db_name}.{collection_name}]: {_filter}&#34;)

        updated_docs_nbr = collection.with_options(write_concern=WriteConcern(&#34;majority&#34;)).update_many(
            filter=_filter,
            update=_append_query(new_data) if append else {&#34;$set&#34;: new_data},
            upsert=True
        ).modified_count

        return updated_docs_nbr</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.valid_object_id"><code class="name flex">
<span>def <span class="ident">valid_object_id</span></span>(<span>oid_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid_object_id(oid_string):
    try:
        ObjectId(oid_string)
        return True
    except:
        return False</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.valid_uuid"><code class="name flex">
<span>def <span class="ident">valid_uuid</span></span>(<span>uuid_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid_uuid(uuid_string):
    try:
        UUID(uuid_string)
        return True
    except ValueError:
        return False</code></pre>
</details>
</dd>
<dt id="licenseware.mongodata.mongodata.validate_data"><code class="name flex">
<span>def <span class="ident">validate_data</span></span>(<span>schema, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Using Marshmallow schema class to validate data (dict or list of dicts)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_data(schema, data):
    &#34;&#34;&#34;
        Using Marshmallow schema class to validate data (dict or list of dicts) 
    &#34;&#34;&#34;

    if isinstance(data, dict):
        data = schema().load(data)

    if isinstance(data, list):
        data = schema(many=True).load(data)

    return data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="licenseware.mongodata.mongodata.Connect"><code class="flex name class">
<span>class <span class="ident">Connect</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connect(object):
    @staticmethod
    def get_connection():
        return MongoClient(os.getenv(&#34;MONGO_CONNECTION_STRING&#34;))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="licenseware.mongodata.mongodata.Connect.get_connection"><code class="name flex">
<span>def <span class="ident">get_connection</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_connection():
    return MongoClient(os.getenv(&#34;MONGO_CONNECTION_STRING&#34;))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="licenseware.mongodata" href="index.html">licenseware.mongodata</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="licenseware.mongodata.mongodata.aggregate" href="#licenseware.mongodata.mongodata.aggregate">aggregate</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.delete" href="#licenseware.mongodata.mongodata.delete">delete</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.delete_collection" href="#licenseware.mongodata.mongodata.delete_collection">delete_collection</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.distinct" href="#licenseware.mongodata.mongodata.distinct">distinct</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.document_count" href="#licenseware.mongodata.mongodata.document_count">document_count</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.fetch" href="#licenseware.mongodata.mongodata.fetch">fetch</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.get_collection" href="#licenseware.mongodata.mongodata.get_collection">get_collection</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.get_db_name" href="#licenseware.mongodata.mongodata.get_db_name">get_db_name</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.get_sortli" href="#licenseware.mongodata.mongodata.get_sortli">get_sortli</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.insert" href="#licenseware.mongodata.mongodata.insert">insert</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.parse_doc" href="#licenseware.mongodata.mongodata.parse_doc">parse_doc</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.parse_match" href="#licenseware.mongodata.mongodata.parse_match">parse_match</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.parse_oid" href="#licenseware.mongodata.mongodata.parse_oid">parse_oid</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.return_collection_name" href="#licenseware.mongodata.mongodata.return_collection_name">return_collection_name</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.update" href="#licenseware.mongodata.mongodata.update">update</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.valid_object_id" href="#licenseware.mongodata.mongodata.valid_object_id">valid_object_id</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.valid_uuid" href="#licenseware.mongodata.mongodata.valid_uuid">valid_uuid</a></code></li>
<li><code><a title="licenseware.mongodata.mongodata.validate_data" href="#licenseware.mongodata.mongodata.validate_data">validate_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="licenseware.mongodata.mongodata.Connect" href="#licenseware.mongodata.mongodata.Connect">Connect</a></code></h4>
<ul class="">
<li><code><a title="licenseware.mongodata.mongodata.Connect.get_connection" href="#licenseware.mongodata.mongodata.Connect.get_connection">get_connection</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>